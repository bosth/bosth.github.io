[{"content":" Primary sources on Syriacs of Ottoman Adıyaman The linked monograph is a transcription Ottoman Turkish into the Latin alphabet of texts relating to the Syriac (Süryânî) community in Adıyaman and its environs. The document is composed of two parts, first being Adıyaman Tarihi, a manuscript written in Syria in the mid-twentieth century. The second part is a collection of articles collected from early-twentieth century Syriac newspapers in both the Ottoman Empire and the United States. All of the above were written in Syro-Ottoman (Ottoman Turkish using the Syriac alphabet) and the transcription reflects the original language. Notably, Adıyaman Tarihi exhibits many non-standard grammatical and orthographic practices, and these have been faithfully preserved here. The document also contains a glossary of Ottoman and Adıyaman dialectal terms so that the texts can be read by modern-day Turkish speakers.\nAdıyaman Tarihi\u003e Adıyaman Tarihi # Adıyaman Tarihi is one of the most remarkable works I have had the pleasure of working on: a first-hand account of the lives of the Syriac population in the Ottoman town of Adıyaman (also known as Hısn-ı Mansûr) during the late Ottoman Empire. The author escapes the local massacres with his life, but in light of ongoing post-war persecution, he eventually flees to mandate Syria, where he would spend the rest of his life.\nPage from Adıyaman Tarihi I gave a talk on the text during SAYFO 1915: An International Conference on the Genocide of Assyrians/Arameans during the First World War held at Freie Universität Berlin in 2015.\nInternational Conference: Seyfo 1915\nA map from the text was also featured on the lovely The Afternoon Map blog devoted to Ottoman and Ottoman-adjacent cartography.1\nAdıyamanlı Süryânîler is available under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. Download Another map I submitted is available as a post entitle The New Assyria.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 January 0001","permalink":"/pages/adiyaman/","section":"Pages","summary":"Primary sources on Syriacs of Ottoman Adıyaman The linked monograph is a transcription Ottoman Turkish into the Latin alphabet of texts relating to the Syriac (Süryânî) community in Adıyaman and its environs.","title":"Adıyamanlı Süryânîler"},{"content":"","date":"1 January 0001","permalink":"/tags/ads-b/","section":"Tags","summary":"","title":"ads-b"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":" An Ottoman constructed language World-famous constructed languages range from Zamenhof\u0026rsquo;s Esperanto to Tolkien\u0026rsquo;s Quenya to hobbyist \u0026ldquo; conlangs\u0026rdquo;, but isn\u0026rsquo;t it surprising to learn that centuries before them, an Ottoman in Egypt created his own language and that a thorough grammar and lexicon survives to this day?\nConlanging before it became cool was the scholar and mystic Mehmed ibn Fethullah ibn Ebü Tâlib, born in Edirne in the mid-16th century and spending the majority of his life in Ottoman Cairo.\nI started writing an English-language overview of Bāla’y-balan\u0026rsquo;s grammar based on both the original text as preserved in Princeton University\u0026rsquo;s library and a modern Turkish translation by Mustafa Koç, Bâleybelen. Muhyî-i Gülşenî. İlk Yapma Dil.\nA page from Kitâb-ı Bâleybelen The \u0026ldquo;full\u0026rdquo; PDF is available for download, but here are a few short excerpts:\nWords in Bāla’y-balan are not required to have vowel harmony, a distinguishing feature of the Turkish language. Words such as qaydak kapı \u0026lsquo;door, gate\u0026rsquo;, which has both a back q and a front k, would not be possible in a pure Turkish word. This point has further significance when we consider Bāla’y-balan’s suffixes, which will not harmonise with the vowels in the root to which they are attached.\nThe Bāla’y-balan plural is created by the addition of the suffix -ā: نو niv \u0026lsquo;flower\u0026rsquo; and نوا nivā \u0026lsquo;flowers\u0026rsquo;. When the base noun already ends with a -ā, then -y- is added as a buffer between the two vowels. When the base noun ends in the vowel ه [a], then the long ā is added, and the ه is vocalised with its consonontal value [h]: ظفه ẓafa \u0026lsquo;book\u0026rsquo;, ظفها ẓafahā.\nA noun may be placed in accusative case by the addition of the suffix -rā. This may be added to both singular and plural nouns: شَمْسَا نِوَارَا Şamsā nivārā \u0026lsquo;They smelled the flowers\u0026rsquo;.\nBāla’y-balan is available under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. Download ","date":"1 January 0001","permalink":"/pages/balaybalan/","section":"Pages","summary":"An Ottoman constructed language World-famous constructed languages range from Zamenhof\u0026rsquo;s Esperanto to Tolkien\u0026rsquo;s Quenya to hobbyist \u0026ldquo; conlangs\u0026rdquo;, but isn\u0026rsquo;t it surprising to learn that centuries before them, an Ottoman in Egypt created his own language and that a thorough grammar and lexicon survives to this day?","title":"Bāla’y-balan"},{"content":"","date":"1 January 0001","permalink":"/tags/boardgames/","section":"Tags","summary":"","title":"boardgames"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/tags/csp/","section":"Tags","summary":"","title":"csp"},{"content":"","date":"1 January 0001","permalink":"/tags/geospatial/","section":"Tags","summary":"","title":"geospatial"},{"content":"","date":"1 January 0001","permalink":"/tags/history/","section":"Tags","summary":"","title":"history"},{"content":"","date":"1 January 0001","permalink":"/","section":"jaxartes.net","summary":"","title":"jaxartes.net"},{"content":"","date":"1 January 0001","permalink":"/tags/language/","section":"Tags","summary":"","title":"language"},{"content":"I want to show that mission-planning in Leaving Earth is just one big constraint satisfaction problem.\nLeaving Earth?\u003e Leaving Earth? # Leaving Earth is a independently-produced boardgame with lovely art that recreates a space race similar to the one between the USSR and the USA. At the start of the game, a handful of missions will be revealed and the players compete to be the first to complete each one, scoring points based on their complexity. Many of these missions are examples of actual human accomplishments - such as Venus Lander - while others - Mars Station - are more fanciful.\nEasy missions in Leaving Earth In real life, the United States would have just edged the Soviet Union 43 points to 42 Mission Planning\u003e Mission Planning # The core mechanic in Leaving Earth is planning the missions using a variety of rockets, capsules and other components to perform a series of maneuvers from one location to another.\nFrom a Lunar orbit, a spacecraft may land on the Moon or fly back to an Earth Orbit The key concept is that each maneuver has a difficulty - roughly approximating Delta-v - and each rocket can produce a certain amount of thrust. The amount of thrust required to perform a maneuver is based on this simple formula: thrust required = mass × difficulty. The final factor, mass, is determined by the number of components aboard the spacecraft.\nA simple mission plan for a spacecraft travelling from Earth to the Lunar surface might look like the following (the numbers in parentheses indicates the mass of that component):\nManeuver Difficulty Rockets Used Payload Required Thrust Earth to Earth Orbit 8 Saturn (20) Atlas (4), Juno (1), Probe (1) 26 × 8 Earth Orbit to Lunar Orbit 3 Atlas (4) Juno (1), Probe (1) 6 × 8 Lunar Orbit to Moon 2 Juno (1) Probe (1) 2 × 2 As long as the rockets used in each stage of this mission can product the required thrust, then the maneuver can be completed. In the example above, a Saturn rocket produces 200 thrust, an Atlas 27 thrust and a Juno 4, so each maneuver succeeds.\nAn alternative route to space would be to use a two-stage launch to avoid the difficulty 8 maneuver required to go directly from the Earth\u0026rsquo;s surface to Earth Orbit.\nManeuver Difficulty Rockets Used Payload Required Thrust Earth to Suborbital Flight 3 Soyuz (9) Soyuz (9), Atlas (4), Juno (1), Probe (1) 24 × 3 Suborbital Flight to Earth Orbit 5 Soyuz (9) Atlas (4), Juno (1), Probe (1) 15 × 5 Earth Orbit to Lunar Orbit 3 Atlas (4) Juno (1), Probe (1) 6 × 8 Lunar Orbit to Moon 2 Juno (1) Probe (1) 2 × 2 A Soyuz produces only 80 thrust, but using it in a two-stage configuration means that it can still reach orbit. In fact, two Soyuz rockets can carry a payload of 7 mass into orbit, whereas a single Saturn can only carry 5. And since in the game\u0026rsquo;s economy a Soyuz only costs $8 compared to a hefty $15 for a Saturn, the former starts to look like an attractive proposition. That is until you start planning, say, a mission to transport humans to Mars along with enough enough rockets to bring them up from the surface so they don\u0026rsquo;t die, costing your space agency precious points.\nThere are many other mission planning complexities: Ion Thrusters, which are not expended but take time to travel from one location to another; slingshot maneuvers to travel to the outer reaches of the solar system; one-way maneuvers; and more. But the basic concept I presented above is enough to move on.\nConstraint Satisfaction Problems\u003e Constraint Satisfaction Problems # So how can Leaving Earth\u0026rsquo;s mission planning be reduced to a Constraint Satisfaction Problem (CSP)?\nLet\u0026rsquo;s take the difficulty 5 maneuver from Earth to Suborbital Flight and rewrite it as a CSP. To simplify things, we\u0026rsquo;ll assume that there are only Saturn and Soyuz rockets available.\nThe Leaving Earth map The question we want to solve is how many Saturn and how many Soyuz rockets are needed to move a mass of, say, 1 from Earth to Suborbital. In other words, we want to find the values of two variables, saturn and soyuz, that are a solution to the following problem:\nBoth variables must be greater or equal to zero (we don\u0026rsquo;t allow negative numbers of rockets):\nsaturn ≥ 0 soyuz ≥ 0 Our Leaving Earth formula thrust required = mass × difficulty needs to be rewritten slightly as thrust produced ≥ mass × difficulty; in other words, we need to make sure that the thrust produced by the Saturn and Soyuz rockets that we use is large enough.\nFirst consider what we know:\npayload = 1 thrust produced = saturn × 200 + soyuz × 80 mass = saturn × 20 + soyuz × 9 + payload difficulty = 5 Then write this information as a third and final constraint:\nsaturn × 200 + soyuz × 80 ≥ (saturn × 20 + soyuz × 9 + 1) × 5 This problem is actually quite easy to solve: any positive values for saturn or soyuz will be a correct solution. But if the payload size increased from 1 to, say, 10, then the solutions are perhaps not so obvious.\nz3\u003e z3 # This is where a CSP solver comes in handy. z3 is a toolkit for solving CSPs with bindings for several languages, including Python, which is the language I\u0026rsquo;ll be using here.\nz3 will help find the right number of rockets to fit the Leaving Earth equation thrust required = mass × difficulty. In other words the formula is our constraint and the number of rockets are the variables that need to be solved for.\nSolving a single maneuver\u003e Solving a single maneuver # Rewriting the CSP above in z3 would look like this:\nfrom z3 import solve, Int saturn = Int(\u0026#34;saturn rockets\u0026#34;) soyuz = Int(\u0026#34;soyuz rockets\u0026#34;) payload = 10 thrust = saturn*200 + soyuz*80 mass = saturn*20 + soyuz*9 + payload difficulty = 5 solve(saturn\u0026gt;=0, soyuz\u0026gt;=0, thrust \u0026gt;= mass * difficulty) z3 will return the following result:\n[saturn rockets = 0, soyuz rockets = 2] In other words, 2 Soyuz rockets can transport a payload of 10 to Suborbital Flight. This certainly is a solution, but is it the optimal solution? For this, we have to decide what defines optimal. Is it the number of rockets? The total mass of the rockets? Or is it the cost of the rockets used? If we are thinking about a game of Leaving Earth, it\u0026rsquo;s probably the cost.\nLet\u0026rsquo;s rewrite the function but with a cost optimization and let\u0026rsquo;s add all the remaining rockets in as variables.\nfrom z3 import Optimize, Int saturn = Int(\u0026#34;saturn rockets\u0026#34;) soyuz = Int(\u0026#34;soyuz rockets\u0026#34;) atlas = Int(\u0026#34;atlas rockets\u0026#34;) juno = Int(\u0026#34;juno rockets\u0026#34;) payload = 10 thrust = saturn*200 + soyuz*80 + atlas*27 + juno*4 mass = saturn*20 + soyuz*9 + atlas*4 + juno*1 + payload difficulty = 5 cost = saturn*15 + soyuz*8 + atlas*5 + juno*1 solver = Optimize() solver.add(thrust \u0026gt;= mass * difficulty) solver.add(saturn \u0026gt;= 0) solver.add(soyuz \u0026gt;= 0) solver.add(atlas \u0026gt;= 0) solver.add(juno \u0026gt;= 0) solver.minimize(cost) solver.check() solver.model() And this returns:\n[saturn rockets = 1, soyuz rockets = 0, atlas rockets = 0, juno rockets = 0] And of course you can get a mix of rockets with the right conditions, such as by setting payload to 21, giving:\n[saturn rockets = 1, soyuz rockets = 0, atlas rockets = 1, juno rockets = 0] Solving longer missions\u003e Solving longer missions # When it\u0026rsquo;s just a single maneuver, the constraints end up being quite simple; however, missions in Leaving Earth inevitably have multiple steps. Fortunately, this is not difficult to express in z3. Let\u0026rsquo;s take the mission from Earth Orbit to the Moon. We have a maneuver of difficulty 3, followed by a maneuver of difficulty 2.\ngraph TD A(Earth) --\u003e|3| B(Suborbital Flight) B --\u003e|5| C(Earth Orbit) A --\u003e|8| C C --\u003e|3| D(Lunar Orbit) D --\u003e|2| E(Moon) The key here is to express this mission backwards; in other words, we\u0026rsquo;ll make sure we can travel from Lunar Orbit to the Moon first and then ensure we can travel from Earth Orbit to Lunar Orbit.\nAnd crucially, the payload gets larger and larger as we move backwards in the mission by the number of rockets that will be expended in the future:\nManeuver Maneuver Difficulty Payload 0 Lunar Orbit to Moon 2 5 1 Earth Orbit to Lunar Orbit 3 5 + mass of rockets used in Stage 0 In z3, this would be:\nfrom z3 import Optimize, IntVector, Int solver = Optimize() maneuvers = [2, 3] # reverse list of maneuvers to perform payload = 5 saturn = IntVector(\u0026#34;saturn rockets\u0026#34;, len(maneuvers)) soyuz = IntVector(\u0026#34;soyuz rockets\u0026#34;, len(maneuvers)) atlas = IntVector(\u0026#34;atlas rockets\u0026#34;, len(maneuvers)) juno = IntVector(\u0026#34;juno rockets\u0026#34;, len(maneuvers)) cost = 0 # running total of the cost for i, difficulty in enumerate(maneuvers): solver.add(saturn[i] \u0026gt;= 0) solver.add(soyuz[i] \u0026gt;= 0) solver.add(atlas[i] \u0026gt;= 0) solver.add(juno[i] \u0026gt;= 0) thrust = saturn[i]*200 + soyuz[i]*80 + atlas[i]*27 + juno[i]*4 thruster_mass = saturn[i]*20 + soyuz[i]*9 + atlas[i]*4 + juno[i]*1 mass = thruster_mass + payload solver.add(thrust \u0026gt;= mass * difficulty) cost += saturn[i]*15 + soyuz[i]*8 + atlas[i]*5 + juno[i]*1 payload += thruster_mass solver.minimize(cost) solver.check() solver.model() Removing all the unused rockets, we are left with the following:\n[atlas rockets0 = 1, soyuz rockets1 = 1] This is saying that for maneuver 0, we need an Atlas and for maneuver 1, we need a Soyuz. Remember that we planned this backwards, so 0 is the last maneuver (i.e. Lunar Orbit to the Moon) and 1 is the maneuver that came before it (i.e. Earth Obit to Lunar Orbit).\nThe amazing thing is that by simply changing the line maneuvers = [2, 3], we can solve any one-way mission in Leaving Earth that uses expendable rockets.\nEarth to the Moon? maneuvers = [2, 3, 8]\nEarth to the Moon with a two stage launch? maneuvers = [2, 3, 5, 3]\nEarth to Mercury with a two stage launch? maneuvers = [2, 2, 5, 3, 5, 3]\nIon Thrusters\u003e Ion Thrusters # Ion Thrusters work a little differently: they can\u0026rsquo;t be used for maneuvers travelling to or from celestial bodies; they are not expended when they are used; they produce 5 thrust for every year the journey takes. As an example, if a spacecraft composed of a Probe (mass 1) and an Ion Thruster (mass 1) travels from Earth Orbit to Lunar Orbit, then the journey will take 2 years to complete. The same formula - thrust required = mass × difficulty - applies, giving (1+1) × 3 = 6. Ion Thrusters generate 5 thrust per year so one year of travel would only provide 5 thrust and we need 6, hence two years.\nSince Ions are not expended, they are very efficient as long as you aren\u0026rsquo;t in a hurry - remember this a space race.\nLet\u0026rsquo;s add support for Ion Thrusters to the code above. First we need to add the Ion Thrusters\u0026rsquo; mass and cost once but add their thrust at each stage. Second, we need to introduce a new variable for the number of years each maneuver takes.\nfrom z3 import Optimize, IntVector, Int solver = Optimize() maneuvers = [2, 5, 3] # reverse list of maneuvers to perform payload = 5 saturn = IntVector(\u0026#34;saturn rockets\u0026#34;, len(maneuvers)) soyuz = IntVector(\u0026#34;soyuz rockets\u0026#34;, len(maneuvers)) atlas = IntVector(\u0026#34;atlas rockets\u0026#34;, len(maneuvers)) juno = IntVector(\u0026#34;juno rockets\u0026#34;, len(maneuvers)) ion = Int(\u0026#34;ion thrusters\u0026#34;) year = IntVector(\u0026#34;years travelled\u0026#34;, len(maneuvers)) solver.add(ion \u0026gt;= 0) cost = 0 # running total of the cost years = 0 # running total of journey time payload += ion * 1 # add the weight of the ion thrusters to the payload once cost += ion * 10 # add the cost of the ion thrusters to the total once for i, difficulty in enumerate(maneuvers): solver.add(saturn[i] \u0026gt;= 0) solver.add(soyuz[i] \u0026gt;= 0) solver.add(atlas[i] \u0026gt;= 0) solver.add(juno[i] \u0026gt;= 0) solver.add(year[i] \u0026gt;= 0) thrust = saturn[i]*200 + soyuz[i]*80 + atlas[i]*27 + juno[i]*4 + ion*year[i]*5 thruster_mass = saturn[i]*20 + soyuz[i]*9 + atlas[i]*4 + juno[i]*1 mass = thruster_mass + payload solver.add(thrust \u0026gt;= mass * difficulty) years += year[i] cost += saturn[i]*15 + soyuz[i]*8 + atlas[i]*5 + juno[i]*1 payload += thruster_mass solver.minimize(cost) solver.check() solver.model() The code above is for a journey from Earth Orbit to Mercury Orbit. Because Ion Thrusters can\u0026rsquo;t be used to reach space from Earth, the code would need to be more complex to support the full journey, but this is good enough for now.\nStage Maneuver Difficulty 0 Mercury Fly-by to Mercury Orbit 2 1 Inner Planets Transfer to Mercury Fly-by 5 2 Earth Orbit to Inner Planets Transfer 3 [ion thrusters = 1, years travelled0 = 3, years travelled1 = 9, years travelled2 = 4] For $10 in game money, a single Ion Thruster will carry a payload all the way to Mercury! The only problem is that it will take 16 years \u0026hellip; but what if we ask z3 to optimize for the journey time?\nsolver.minimize(cost) solver.minimize(years) Now cost is still the most important factor but years will also be minimized and the new results are that the journey will take 13 years. You can also flip the order of the two minimize statements so that the critical factor is the journey time and cost is only of secondary importance!\n[juno rockets0 = 5, saturn rockets1 = 1, saturn rockets2 = 1] Now suddenly, z3 wants us to use expendable rockets fore each maneuver because they don\u0026rsquo;t have the additional time cost of the Ion Thrusters.1 The monetary cost is significantly higher, however, at $35!\nLeaving Earth Solver\u003e Leaving Earth Solver # I put all of this and more together into a Python package to solve many (but not all) Leaving Earth missions, including rules from Outer Planets and Stations. It\u0026rsquo;s a command-line tool that works like this:\nUsage: les [OPTIONS] ORIGIN DESTINATION [PAYLOAD] Options: --version Show the version and exit. -v, --verbose Verbose mode -j, --juno RANGE Number of Juno rockets -a, --atlas RANGE Number of Atlas rockets -s, --soyuz RANGE Number of Soyuz rockets -p, --proton RANGE Number of Proton rockets -n, --saturn RANGE Number of Saturn rockets -i, --ion RANGE Number of Ion thrusters -c, --cost RANGE Cost of mission -m, --minimize [time|cost|mass] Minimization goal --single-stage Check a single stage configuration for launches from Earth (by default only a two- stage configuration will be attempted) --aerobraking / --no-aerobraking Use aerobraking --rendezvous / --no-rendezvous If rendezvous technology is available, Ion thrusters will be detached when no longer needed -t, --time RANGE Number of time tokens -y, --year INTEGER RANGE Year that journey starts [1956\u0026lt;=x\u0026lt;=1986] --help Show this message and exit. Source code Examples\u003e Examples # To find the optimal solution for a trip taking 1 mass from Earth Orbit (Eo) to the Moon (L):\nles Eo L The results are a JSON description of the entire mission:\n{ \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 5 }, \u0026#34;payload\u0026#34;: 1, \u0026#34;mass\u0026#34;: 5, \u0026#34;cost\u0026#34;: 5, \u0026#34;time\u0026#34;: 0, \u0026#34;plan\u0026#34;: [ { \u0026#34;origin\u0026#34;: \u0026#34;Earth orbit\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;Lunar fly-by\u0026#34;, \u0026#34;difficulty\u0026#34;: 1, \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 2 }, \u0026#34;thrust\u0026#34;: 8 }, { \u0026#34;origin\u0026#34;: \u0026#34;Lunar fly-by\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;Lunar orbit\u0026#34;, \u0026#34;difficulty\u0026#34;: 2, \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 2 }, \u0026#34;thrust\u0026#34;: 8 }, { \u0026#34;origin\u0026#34;: \u0026#34;Lunar orbit\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;Moon\u0026#34;, \u0026#34;difficulty\u0026#34;: 2, \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 1 }, \u0026#34;thrust\u0026#34;: 4 } ] } This plan uses Lunar Fly-by because of the low difficulty maneuver from Earth Orbit To find the optimal solution for a trip that taking 5 mass from Earth (E) to the Moon that uses no Saturn rockets, between 1 and 3 Soyuz rockets and where we are able to detatch the Ion Thruster before landing on the Moon (this avoids moving unnecessary mass):\nles E L 5 --saturn 0 --soyuz 1-3 --rendezvous To find the optimal solution for the fastest trip carrying 10 mass from Earth Orbit to Jupiter Fly-by (Jfb) that leaves in 1960.\nles Eo Jfb 10 --year 1960 --minimize time Result:\n{ \u0026#34;start\u0026#34;: 1960, \u0026#34;end\u0026#34;: 1963, \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 3, \u0026#34;soyuz\u0026#34;: 1, \u0026#34;ion\u0026#34;: 1, \u0026#34;atlas\u0026#34;: 1 }, \u0026#34;payload\u0026#34;: 10, \u0026#34;mass\u0026#34;: 17, \u0026#34;cost\u0026#34;: 26, \u0026#34;time\u0026#34;: 3, \u0026#34;plan\u0026#34;: [ { \u0026#34;origin\u0026#34;: \u0026#34;Earth orbit\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;Inner planets transfer\u0026#34;, \u0026#34;difficulty\u0026#34;: 3, \u0026#34;components\u0026#34;: { \u0026#34;soyuz\u0026#34;: 1, \u0026#34;ion\u0026#34;: 1 }, \u0026#34;aerobraking\u0026#34;: false, \u0026#34;year\u0026#34;: 1960, \u0026#34;time\u0026#34;: 1, \u0026#34;thrust\u0026#34;: 85, \u0026#34;slingshot\u0026#34;: false }, { \u0026#34;origin\u0026#34;: \u0026#34;Inner planets transfer\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;Venus fly-by\u0026#34;, \u0026#34;difficulty\u0026#34;: 2, \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 1, \u0026#34;atlas\u0026#34;: 1, \u0026#34;ion\u0026#34;: 1 }, \u0026#34;aerobraking\u0026#34;: false, \u0026#34;time\u0026#34;: 1, \u0026#34;year\u0026#34;: 1961, \u0026#34;thrust\u0026#34;: 36, \u0026#34;slingshot\u0026#34;: false }, { \u0026#34;origin\u0026#34;: \u0026#34;Venus fly-by\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;Jupiter fly-by\u0026#34;, \u0026#34;difficulty\u0026#34;: 1, \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 2, \u0026#34;ion\u0026#34;: 1 }, \u0026#34;aerobraking\u0026#34;: false, \u0026#34;year\u0026#34;: 1962, \u0026#34;time\u0026#34;: 1, \u0026#34;thrust\u0026#34;: 13, \u0026#34;slingshot\u0026#34;: true } ] } How it works\u003e How it works # The core concept is identical to what I described above but les also finds the optimal paths from the origin to the destination. In most cases there are multiple paths between two points and the optimal path depends on a number of external factors. Even travelling to the Moon from Earth presents many options:\ngraph TD E((Earth)) --\u003e|3| ESo(Suborbital Flight) ESo --\u003e|5| Eo(Earth Orbit) E --\u003e|8| Eo Eo --\u003e|3| Lo(Lunar Orbit) Lo --\u003e|2| L((fa:fa-ban Moon)) Eo --\u003e|1| Lfb(Lunar Fly-by) Lfb --\u003e|2| Lo Lfb --\u003e|4| L By default, les will try to predict a few plausible paths and solve for each of those, selecting the best solution at the end.\nles is aware of which maneuvers support Ion Thrusters and can detatch these opportunistically when they will no longer be needed to complete a mission. Conversely, it will carry unused Ions from one location to the next if they will be used at a future stage.\nIt also can make use of aerobraking, slingshot maneuvers and Proton rockets from the expansions. It doesn\u0026rsquo;t support the resuable shuttles, however, and it won\u0026rsquo;t increase or decrease the difficulty of maneuvers to change travel times. The biggest missing feature, howver, is probably not being able to plan return missions (e.g. going to the Moon and back again).\nLeaving Earth players will note that some maneuvers take a minimum amount of time even with rockets, but I am ignoring that for the moment.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 January 0001","permalink":"/pages/leaving-earth/","section":"Pages","summary":"I want to show that mission-planning in Leaving Earth is just one big constraint satisfaction problem.\nLeaving Earth?\u003e Leaving Earth? # Leaving Earth is a independently-produced boardgame with lovely art that recreates a space race similar to the one between the USSR and the USA.","title":"Leaving Earth is a Constraint Satisfaction Problem"},{"content":" An Ottoman Turkish tautology Wikipedia has an article on a place called Pendle Hill, noteworthy, perhaps, mainly for being a triple tautology:\nThe name \u0026ldquo;Pendle Hill\u0026rdquo; combines the words for hill from three different languages \u0026hellip; In the 13th century it was called Pennul or Penhul, apparently from the Cumbric pen and Old English hyll, both meaning \u0026ldquo;hill\u0026rdquo;. The modern English \u0026ldquo;hill\u0026rdquo; was appended later, after the original meaning of Pendle had become opaque.\nThis reminded me of a similar triple tautology I came across as a graduate student reading copies of a monthly journal from the early twentieth century.\nMürşid-i Âsûriyûn, May 1912 Reading right-to-left, you can see it right there at the start of the second line: ܔܒܠܛܘܪ ܛܐܓ݂ . That\u0026rsquo;s cebel (Arabic for \u0026ldquo;mountain\u0026rdquo;), tûr (Syriac for \u0026ldquo;mountain\u0026rdquo;) and dağ (Turkish for, you guessed it, \u0026ldquo;mountain\u0026rdquo;).1\nThe text above was written in Ottoman Turkish, and for consistency, I am using standard Turkish transliteration for all the foreign language words. It\u0026rsquo;s worth pointing out that cebel is pronounced \u0026ldquo;jebel\u0026rdquo;. The \u0026ldquo;mountain\u0026rdquo; in question here was actually the Tur Abdin region in modern Turkey, ironically a region that has no mountains and can be described as hilly at best.\nAs a small aside, the journal Mürşid-i Âsûriyûn that this place name came from is interesting a in a few ways:\nIf the image above looks handwritten, that\u0026rsquo;s because it was. The publisher, Âşûr Yûsuf, printed copies using a technique called mimeography. The journal existed between 1909 and 1914 in the ancient city of Harpût, then a provincial capital and was mailed to subscribers across the Ottoman Empire and as far away as the United States. This preserved copy comes from a subscriber in Massachusetts. Ottoman Turkish was usually written using the Arabic alphabet, but Âşûr Yûsuf used the Syriac alphabet in Mürşid-i Âsûriyûn. This was the first journal to be printed in Ottoman Turkish with Syriac letters, but it was followed by several more. You could still find them being published in Lebanon and the United States into the 1930s. Syriac Arabic Latin ܔܒܠ جبل cebel ܛܘܪ طور tûr ܛܐܓ݂ طاغ dağ Âşûr Yûsuf was a native speaker of Armenian and he did not know the Syriac language, despite identifying as a Syriac (Süryânî) and an Assyrian (Âsûrî). Like any other speaker of Ottoman Turkish, he would have been well-acquainted with the common word cebel despite not speaking Arabic himself.\nIt\u0026rsquo;s interesting to compare his usage to some other notable topological features in the Ottoman Empire:\nMount Sinai is جبل الطور (Cebel et-Tûr) in Arabic and was جبل طور (Cebel‑i Tûr) in Ottoman Turkish.2 The Mount of Olives near Jerusalem was also Cebel‑i Tûr (although it is simply الطور in Arabic). Mount Gerizim near Nablus is another Cebel et-Tûr. In the Arabic and the Ottoman cases where we find both cebel and tûr, speakers would have understood these names to mean something like \u0026ldquo;Tûr Mountain\u0026rdquo;.\nWhen I originally read the passage above, I also transliterated the place name as Cebel‑i Tûr Dağı, but looking at the text again, I can see that the author intended it to be read Cebeltûr Dağı. My original reading would have required a space between the first two words, so ܔܒܠ ܛܘܪ ܛܐܓ݂ , but that space is quite clearly not there: ܔܒܠܛܘܪ ܛܐܓ݂ .\nAnd that, I suppose, is the difference. Cebel-i Tûr (with a space) was \u0026ldquo;Mount Tûr\u0026rdquo; and no Dağ was necessary or even possible. But Cebeltûr (no space) had become a set phrase much like Penhul. And it was acceptable for a Turkish-speaker to call this place Cebeltûr Dağı: \u0026ldquo;Mount Cebeltûr\u0026rdquo;.\nObservant readers will note that it is actually ܔܒܠܛܘܪ ܛܐܓ݂ܢܢ in the original text but the final two characters are the Turkish grammatical suffix -ının which we can ignore.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIn Turkish today, Tûr Dağı has replaced the Persian grammatical construct which you see in Cebel-i Tûr. And both now and then, Mount Sinai had many different names, including Cebel-i Sînâ.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 January 0001","permalink":"/pages/mt-mountain-mountain/","section":"Pages","summary":"An Ottoman Turkish tautology Wikipedia has an article on a place called Pendle Hill, noteworthy, perhaps, mainly for being a triple tautology:\nThe name \u0026ldquo;Pendle Hill\u0026rdquo; combines the words for hill from three different languages \u0026hellip; In the 13th century it was called Pennul or Penhul, apparently from the Cumbric pen and Old English hyll, both meaning \u0026ldquo;hill\u0026rdquo;.","title":"Mount Mountain Mountain"},{"content":"ADS-B data\u003e ADS-B data # Can standard geospatial tools be used with transmissions from Automatic Dependent Surveillance-Broadcast (ADS-B) equipment aboard aircraft? I wanted to find out because unlike most geospatial data, ADS-B has a third dimension and a fourth dimension.\nMy geospatial analysis tool of choice is PostGIS, which has multidimensional geometry types and functions, but I had never really had cause to use them despite having coded support for additional dimensions when I developed plpygis.\nThis article describes the process of getting free ADS-B data, loading it into PostgreSQL and then manipulating it with PostGIS and Python.\nTools\u003e Tools # In addition to PostgreSQL and PostGIS, I used two Python modules: requests and plpygis. These must be installed in a location from which PostgreSQL’s PL/Python can import them. I also used QGIS for visualization.\nAircraft identities\u003e Aircraft identities # Step one was learning about ICAO 24 addresses, unique aircraft identifiers which are included in every ADS-B transmission.1 These are 24-bit values represented by a six-digit hexadecimal number, such as A4DA1. These codes are distinct from the registration numbers that are visible on an aircraft\u0026rsquo;s body or tail.\nUzbekistan Airways IL-76 with registration UK-76428 A single physical aircraft may have multiple ICAO 24 addresses over its lifetime but these change much less frequently than registration numbers.\nDrukair ATR-42 with the registration number A5-RGH (via www.planespotters.net) The ATR-42 in the image above has moved between three airlines and therefore been registered under three different numbers … but also with two different ICAO 24 codes, 3a2270 and 39ad00. The history of these alterations can be found in some databases, such as the one maintained by Planespotters.net.\nThe OpenSky Network\u003e The OpenSky Network # The The OpenSky Network provides free access to ADB-S data via a RESTful API. There is a Python client, but I did not use it since it doesn’t implement everything that is available directly through the API.\nAn ICAO 24 address2 is the basis for most OpenSky API calls, although it is possible to request data by searching for activity at a particular airport or region.\nI created a free OpenSky account since the API documentation states that the rate limits are stricter for anonymous users. And although my experience is that the API behaviour does not always match the documentation, it seemed like a good idea to do what they recommend in this case.\nState vectors\u003e State vectors # Equipped with an ICAO 24 number, I retrieved some actual flight data provided by OpenSky. A basic query also requires a specific time, with that time being represented as the number of seconds elapsed since the 1st of January 1970 (otherwise known as UNIX time). For example, the position of the ATR-42 above at 16:01:23 on the 11th of April, 2022 is requested by https://opensky-network.org/api/states/all?icao24=39ad00\u0026time=1649692883.\nThe JSON-encoded response looks like the following:\n{ \u0026#34;time\u0026#34;: 1649692883, \u0026#34;states\u0026#34;: [ [ \u0026#34;39ad00\u0026#34;, \u0026#34;AFR57AG \u0026#34;, \u0026#34;France\u0026#34;, 1649692879, 1649692882, 2.5172, 44.9426, 2263.14, false, 100.86, 24.08, 10.08, null, 2316.48, null, false, 0 ] ] } The data transmitted by the aircraft is stored in the list of states and can be decoded through the OpenSky documentation. From this you know that the aircraft was operating as Air France 57AG, that it recorded a barometric altitude of 2263.14 meters, that it had a ground speed of 100.86 meters/second and so on.\nBack to my Il-76 in Tashkent, planefinder tells me that the ICAO 24 code associated with UK-76428 is 507f87. As it turns out, OpenSky doesn’t have any records of that particular airplane flying, which is, I suppose, an answer to my original question of what these planes might be up to: not much, or at least not much in the range of a receiver operated by someone participating in the OpenSky Network. But there are plenty of other planes in the sky to look at!\nTracks\u003e Tracks # OpenSky simplifies getting a series of state vectors by providing a tracks API endpoint, and although the documentation states that this endpoint is experimental, I’ve had success in using it: https://opensky-network.org/api/tracks/?icao24=39ad00\u0026time=1649692883.\nThe response to the request above will contain some basic facts about the flight, including the first and last times at which it was observed:\n{ \u0026#34;icao24\u0026#34;: \u0026#34;39ad00\u0026#34;, \u0026#34;callsign\u0026#34;: \u0026#34;AFR57AG \u0026#34;, \u0026#34;startTime\u0026#34;: 1649692883, \u0026#34;endTime\u0026#34;: 1649696435, \u0026#34;path\u0026#34;: [...] } The path element is a list of abbreviated state vectors showing the route the aircraft took on this flight. One of these vectors might look like the following:\n[ 1649693075, 45.129, 2.631, 3352, 23, false ] These values are the time, latitude, longitude, barometric altitude, heading and whether the aircraft is on the ground respectively.3\nThe one significant limitation with OpenSky is that these flight tracks are only available for flights from the last 30 days.\nFlights\u003e Flights # The next endpoint that we’ll be using is /flights/aircraft, which lists all the flights taken by an aircraft: https://opensky-network.org/api/flights/aircraft/?icao24=39ad00\u0026begin=1609455600\u0026end=1609714800.\nOne flight in the list looks like the following:\n{ \u0026#34;icao24\u0026#34;: \u0026#34;39ad00\u0026#34;, \u0026#34;firstSeen\u0026#34;: 1649692883, \u0026#34;estDepartureAirport\u0026#34;: \u0026#34;LFLW\u0026#34;, \u0026#34;lastSeen\u0026#34;: 1649696438, \u0026#34;estArrivalAirport\u0026#34;: \u0026#34;LFPO\u0026#34;, \u0026#34;callsign\u0026#34;: \u0026#34;AFR57AG \u0026#34;, \u0026#34;estDepartureAirportHorizDistance\u0026#34;: 9750, \u0026#34;estDepartureAirportVertDistance\u0026#34;: 1654, \u0026#34;estArrivalAirportHorizDistance\u0026#34;: 3750, \u0026#34;estArrivalAirportVertDistance\u0026#34;: 33, \u0026#34;departureAirportCandidatesCount\u0026#34;: 0, \u0026#34;arrivalAirportCandidatesCount\u0026#34;: 9 } The departure and arrival airports are estimates since these are not explicitly reported by the ADB-S data, so OpenSky infers them from what it observes; on occasion you will see an airport listed as null when there wasn’t enough data to establish what the plane’s origin or destination were.\nAny time between firstSeen and lastSeen can be used with the /tracks endpoint above to get the entire path that the plane took on this flight.\nAirport activity\u003e Airport activity # Two final endpoints that are interesting are /flights/arrival and /flights/departure, which will list all the flights that terminate or originate at a particular airport between two points in time.\nADS-B data in PostGIS\u003e ADS-B data in PostGIS # Database creation\u003e Database creation # Once PostgreSQL and PostGIS are installed and your user has the right privileges, you can run the following on the command line:\ncreatedb opensky Then open the database to interact with it:\npgsql opensky You first need to enable PostGIS:\nCREATE EXTENSION postgis; Create the table to store the flight data:\nCREATE TABLE flight ( icao24 TEXT, callsign TEXT, dep_airp TEXT, -- departure airport arr_airp TEXT, -- arrival airport dep_time TIMESTAMP, -- departure time arr_time TIMESTAMP, -- arrival time geom GEOMETRY(LINESTRINGZM, 4326) ); The geometry type LINESTRINGZM means that each vertex in the path will have four dimensions: x and y (longitude and latitude), z (altitude) and m (the “measure” value, which will be used for time).\nFinally, add an index but make it n-dimensional, which optimizes queries across all four dimensions.\nCREATE INDEX ON flight USING gist (geom gist_geometry_ops_nd); PL/Python\u003e PL/Python # There are a few ways to bring the data from the OpenSky API into the database, but I used PL/Python, which means we’ll write a function in Python that will be run from inside the database. To make it easier to work with PostGIS, I also used plpygis, a small Python module that I created to help write PL/Python functions for geospatial data.\nStart by enabling PL/Python:\nCREATE LANGUAGE plpython3u; Let’s start with a simple function that gets a list of flights an aircraft took between two dates.\nCREATE OR REPLACE FUNCTION get_aircraft_flights(icao24 TEXT, in_datebegin DATE, in_dateend DATE) RETURNS TABLE (LIKE flight) AS $$ OSUSER = \u0026#39;YOUR_USERNAME\u0026#39; OSPW = \u0026#39;YOUR_PASSWORD\u0026#39; OSURL = \u0026#34;https://opensky-network.org/api\u0026#34; from datetime import datetime from dateutil import parser from requests import Session from requests.auth import HTTPBasicAuth db = parser.parse(in_datebegin) de = parser.parse(in_dateend).replace(hour=23, minute=59) db = int(db.timestamp()) de = int(de.timestamp()) opensky = Session() opensky.auth = HTTPBasicAuth(OSUSER, OSPW) res = opensky.get( OSURL + \u0026#34;/flights/aircraft/\u0026#34;, params={\u0026#34;icao24\u0026#34; : icao24, \u0026#34;begin\u0026#34; : db, \u0026#34;end\u0026#34; : de}) if res.status_code == 200 and res.text: plpy.info(res.request.url) flights = [(icao24, f[\u0026#34;callsign\u0026#34;].strip() if f[\u0026#34;callsign\u0026#34;] else \u0026#34;\u0026#34;, f[\u0026#34;estDepartureAirport\u0026#34;], f[\u0026#34;estArrivalAirport\u0026#34;], datetime.fromtimestamp(f[\u0026#34;firstSeen\u0026#34;]), datetime.fromtimestamp(f[\u0026#34;lastSeen\u0026#34;]), None) for f in res.json()] return flights else: plpy.info(res.request.url, res.status_code, res.text) return [] $$ LANGUAGE plpython3u; The function definition get_aircraft_flights takes three arguments, the ICAO 24 code discussed above plus a start and an end date. Returning TABLE (LIKE flight) is a rather useful way that PostgreSQL lets you force the output of a function to match exactly the definition of a table.4\nThe function makes a call to the OpenSky API to get all the flights for the aircraft between the two dates, and returns the results. It does not fill in the track for each flight, but we can write another function to do that:\nCREATE OR REPLACE FUNCTION get_track(icao24 TEXT, in_date TIMESTAMP WITH TIME ZONE) RETURNS GEOMETRY(LINESTRINGZM, 4326) AS $$ OSUSER = \u0026#39;YOUR_USERNAME\u0026#39; OSPW = \u0026#39;YOUR_PASSWORD\u0026#39; OSURL = \u0026#34;https://opensky-network.org/api\u0026#34; from datetime import datetime from dateutil import parser from requests import Session from requests.auth import HTTPBasicAuth from plpygis import LineString dt = parser.parse(in_date) dt = int(dt.timestamp()) opensky = Session() opensky.auth = HTTPBasicAuth(OSUSER, OSPW) res = opensky.get( OSURL + \u0026#34;/tracks/\u0026#34;, params={\u0026#34;icao24\u0026#34; : icao24.lower(), \u0026#34;time\u0026#34; : dt}) if res.status_code == 200 and res.text: plpy.info(res.request.url) fl = res.json() return LineString( [[v[2], v[1], v[3], v[0]] for v in fl[\u0026#34;path\u0026#34;]]) else: plpy.info(res.request.url, res.status_code, res.text) return None $$ LANGUAGE plpython3u; Now you can use SQL on the results of this function as if it were a normal database table. For example if you want to know all the unique flight numbers flown by 39ad00 in the first week of May, you can query the OpenSky API like this:\nSELECT DISTINCT callsign FROM get_aircraft_flights(\u0026#39;c05f01\u0026#39;, \u0026#39;2022-05-01\u0026#39;, \u0026#39;2022-05-07\u0026#39;); callsign ---------- JZA653 JZA652 JZA270 JZA283 JZA651 JZA161 JZA399 JZA300 JZA157 JZA460 JZA801 JZA349 JZA279 JZA322 JZA658 JZA164 JZA282 JZA153 JZA156 JZA295 JZA147 JZA400 JZA810 JZA800 JZA654 JZA803 JZA160 JZA459 One issue that you will observe doing the above is that you are pulling data from the API with every query. It will be much better to have a local copy of the data to work with:\nINSERT INTO flight SELECT * FROM get_aircraft_flights(\u0026#39;c05f01\u0026#39;, \u0026#39;2022-05-01\u0026#39;, \u0026#39;2022-05-07\u0026#39;); Now the same queries can be run locally from our flight table:\nSELECT DISTINCT callsign FROM flight; And how do we add the tracks?\nUPDATE flight SET geom = get_track(icao24, dep_time) WHERE date(dep_time) = \u0026#39;2022-05-01\u0026#39;; Remove the WHERE clause and you’ll add tracks to all the flights in your table (which could take a very long time depending on what you have put in there). To add geometries to all the flights without them, you can change the where clause to WHERE geom IS NULL.\nAnd, of course, you can hook the table up to QGIS to see those flight paths.\nFlight tracks rendered in QGIS Geospatial queries\u003e Geospatial queries # With the data in PostGIS, let’s do some analysis.\nLet’s start easy and say that you want to know how many kilometers 39ad00 flew on the 1st of May:\nSELECT count(*) AS flights, SUM(ST_Length(geom::geography)) / 1000 AS distance FROM flight WHERE date(dep_time) = \u0026#39;2022-05-01\u0026#39;; flights | distance ---------+------------------- 5 | 1499.689291267288 A little more advanced is seeing how often 39ad00 flew between two Canadian airports but travelled over the landmass of the United States to get there. To do this, I downloaded the administrative boundaries data set from NaturalEarth and after unzipping it, I loaded it into the opensky database:\nshp2pgsql -s 4326 -g geom ne_10m_admin_0_countries.shp country | psql opensky And the I ran the following query to find instances when the start and end of a flight were in Canada but at some point the flight path intersected with US territory:\nSELECT f.callsign, f.dep_time, f.dep_airp, f.arr_airp FROM flight AS f, country AS usa, country AS canada WHERE usa.name = \u0026#39;United States of America\u0026#39; AND canada.name = \u0026#39;Canada\u0026#39; AND ST_Intersects(canada.geom, ST_StartPoint(f.geom)) AND ST_Intersects(canada.geom, ST_EndPoint(f.geom)) AND ST_Intersects(usa.geom, f.geom); callsign | dep_time | dep_airp | arr_airp ----------+---------------------+----------+---------- JZA474 | 2022-05-13 01:10:16 | CYCD | CYYC Showing that particular flight in QGIS, we can see how it did, in fact, pass over the United States during its flight.\nJazz Air flight 474 crossed Washington state on its departure from Nanaimo Going multidimensional\u003e Going multidimensional # Crossed Paths\u003e Crossed Paths # With some data in our flight table, we can do multidimensional analysis using three dimensions as described in the PostGIS documentation.\nLet\u0026rsquo;s start by seeing if any of the flights had an exact intersections of their flight paths.\nSELECT a.callsign, a.dep_time, b.callsign, b.dep_time, ST_AsText(ST_Intersection(a.geom, b.geom)) FROM flight AS a, flight AS b WHERE a.dep_time \u0026gt; b.dep_time AND ST_Intersects(ST_Force3D(a.geom), ST_Force3D(b.geom)); Note that we are forcing the geometries to be three-dimensional and not four-dimensional. A two-dimentional intersection would ignore altitude completely, while a four-dimensional intersection would be asking for two planes that crossed paths at the exact same point at the exact same time, otherwise known as a mid-air collision.\nAmong the results is something like this, where we can see the exact three-dimensional point at which the paths of Jazz Air flights 168 and 150 intersected one another.\nJZA168 | 2022-06-07 04:49:17 | JZA150 | 2022-06-06 18:15:24 | POINT Z (-123.28160909937012 48.72753520085094 609) The intersection point is expressed in three-dimensional WKT, POINT Z (-123.28160909937012 48.72753520085094 609), where the 609 indicates that the planes were at an altitude of 609 metres or about 2000 feet, a reasonable altitude for planes on approach to an airport.\nFlight tracks for JZA168 and JZA150 crossing paths Click here to see the 3d model above (vertical scale has been exaggerated).\nFour dimensions\u003e Four dimensions # Closest points of approach\u003e Closest points of approach # A four-dimensional intersection is a mid-air collision, and Canada\u0026rsquo;s Civil Aviation Daily Occurrence Reporting System has a queryable database of \u0026ldquo;occurrences\u0026rdquo; on the Transport Canada website. By filtering on the string \u0026ldquo;TCAS\u0026rdquo;5, I found the following incident:\nUPDATE: TSB Report #A22O0076: C-FAXD, a Boeing 737 MAX 8 aircraft operated by Sunwing Airlines Inc, was conducting flight SWG443 from Punta Cana International Airport (PUJ/MDPC), Dominican Republic, to Toronto Pearson International Airport (CYYZ), ON. While on final approach into CYYZ for Runway 33L, the flight crew received a Traffic Alert and Collision Avoidance System (TCAS) resolution advisory (RA) with C-GJVT, an Airbus 320-200 aircraft operated by Air Canada conducting flight ACA264 from Winnipeg/James Armstrong Richardson International Airport (CYWG), MB, to CYYZ, which was on final approach for Runway 33R. SWG443 followed the TCAS RA and aborted the approach to the left. Both aircraft came to a minimum lateral separation of 0.6 Nautical Miles and a minimum vertical separation of 500 feet. SWG443 was at an altitude of 3500 feet and ACA264 at 3000 feet, abeam to each other, on approach for Runways 33L and 33R. SWG443 and ACA264 landed without further incident.\nI wanted to see if I could replicate this narrative in ADS-B data. The first problem is that all the data in the flight table comes from the same airplane, so I added a new function that ingests all the tracks arriving or departing from a specific airport.\nCREATE OR REPLACE FUNCTION get_airport_flights(airport TEXT, in_datebegin DATE, in_dateend DATE) RETURNS TABLE (LIKE flight) AS $$ OSUSER = \u0026#39;YOUR_USERNAME\u0026#39; OSPW = \u0026#39;YOUR_PASSWORD\u0026#39; OSURL = \u0026#34;Thttps://opensky-network.org/api\u0026#34; from datetime import datetime from dateutil import parser from requests import Session from requests.auth import HTTPBasicAuth db = parser.parse(in_datebegin) de = parser.parse(in_dateend).replace(hour=23, minute=59) db = int(db.timestamp()) de = int(de.timestamp()) opensky = Session() opensky.auth = HTTPBasicAuth(OSUSER, OSPW) for endpoint in [\u0026#34;arrival\u0026#34;, \u0026#34;departure\u0026#34;]: res = opensky.get( OSURL + \u0026#34;/flights/{}/\u0026#34;.format(endpoint), params={\u0026#34;airport\u0026#34; : airport, \u0026#34;begin\u0026#34; : db, \u0026#34;end\u0026#34; : de}) if res.status_code == 200 and res.text: plpy.info(res.request.url) for f in res.json(): if not f[\u0026#34;firstSeen\u0026#34;] or not f[\u0026#34;lastSeen\u0026#34;]: continue yield (f[\u0026#34;icao24\u0026#34;], f[\u0026#34;callsign\u0026#34;].strip() if f[\u0026#34;callsign\u0026#34;] else \u0026#34;\u0026#34;, f[\u0026#34;estDepartureAirport\u0026#34;], f[\u0026#34;estArrivalAirport\u0026#34;], datetime.fromtimestamp(f[\u0026#34;firstSeen\u0026#34;]), datetime.fromtimestamp(f[\u0026#34;lastSeen\u0026#34;]), None) else: plpy.info(res.request.url, res.status_code, res.text) $$ LANGUAGE plpython3u; I populated it with the flights to and from CYYZ on the date of the incident.\nCREATE TABLE tcas (LIKE flight); INSERT INTO tcas SELECT * FROM get_airport_flights(\u0026#39;CYYZ\u0026#39;, \u0026#39;2022-06-18\u0026#39;, \u0026#39;2022-06-18\u0026#39;); I could have ingested all the tracks for every row in the table, but since I already knew the affected flights, I just focused on those.\nUPDATE tcas SET geom = get_track(icao24, dep_time) WHERE callsign IN (\u0026#39;ACA264\u0026#39;, \u0026#39;SWG443\u0026#39;); After adding the tracks, the PostGIS function ST_ClosestPointOfApproach can tell us where along the timelines of two flights are they at their closest proximity. We will, however, want to have the geometry reprojected into a spatial reference system that makes distance calculations using metres - not latitude and longitude - since that is what the altitude is measured in. Since the data set is clustered around Victoria, EPSG:7991 is a good choice.\nST_ClosestPointOfApproach finds the measure value at which two tracks are closest to one another. ST_DistanceCPAprovides the actual three-dimensional distance between the two tracks at this closest point of approach.\nWITH flights AS ( SELECT a.callsign AS fa, b.callsign AS fb, ST_Transform(a.geom, 7991) AS ga, ST_Transform(b.geom, 7991) AS gb FROM tcas AS a, tcas AS b WHERE a.callsign = \u0026#39;ACA264\u0026#39; AND b.callsign = \u0026#39;SWG443\u0026#39; ), cpa AS ( SELECT fa, fb, ga, gb, ST_ClosestPointOfApproach(ga, gb) AS m FROM flights ), points AS ( SELECT fa, fb, ST_Force3DZ(ST_GeometryN(ST_LocateAlong(ga, m), 1)) AS pa, ST_Force3DZ(ST_GeometryN(ST_LocateAlong(gb, m), 1)) AS pb, ST_DistanceCPA(ga, gb) AS distance, m FROM cpa ) SELECT to_timestamp(m) AT TIME ZONE \u0026#39;UTC\u0026#39; AS time, round(distance) AS separation, round(ST_Distance(ST_Force2D(pa), ST_Force2D(pb))) AS lateral_separation, round(abs(ST_Z(pa) - ST_Z(pb))) AS vertical_separation, fa AS a, fb AS b, ST_AsText(ST_Transform(pa, 4326), 3) AS a_position, ST_AsText(ST_Transform(pb, 4326), 3) AS b_position FROM points; According to Transport Canada, the lateral separation at 22:39 UTC should be 0.6 nautical miles, which is is 1111 metres, and the vertical separation should be approximately 500 feet. The ADS-B data doesn\u0026rsquo;t exactly replicate those findings but it\u0026rsquo;s not hugely far off.\ntime | separation | lateral_separation | vertical_separation | a | b | a_position | b_position ---------------------+------------+--------------------+---------------------+--------+--------+----------------------------------+------------------------------ 2022-06-18 22:38:07 | 1119 | 1075 | 310 | ACA264 | SWG443 | POINT Z (-79.448 43.542 604.234) | POINT Z (-79.457 43.536 914) The altitude of the two flights does not match the altitudes stated by Transport Canada; however, the altitude reported by these two aircraft on the ground at Toronto was 0, so adding ~170m to account for the airport\u0026rsquo;s elevation does bring us into that range.\nFlight tracks for ACA264 and SWG443 and their positions when at their closest Searching for near misses\u003e Searching for near misses # Lastly, I wanted to see if there were any \u0026ldquo;close calls\u0026rdquo; like the one above that were not reported in the Transport Canada database.\nLet\u0026rsquo;s load the in-bound and out-bound flights at Victoria International Airport (YYJ) on a single day:\nINSERT INTO flight SELECT * FROM get_airport_flights(\u0026#39;CYYJ\u0026#39;, \u0026#39;2022-06-15\u0026#39;, \u0026#39;2022-06-15\u0026#39;); From this we will see for all flights that have any temporal overlap, there is a single time at which the two flights were closest to one another.\nSELECT to_timestamp(ST_ClosestPointOfApproach(ST_Transform(a.geom, 3005), ST_Transform(b.geom, 3005))) AS time, a.callsign AS flight_a, b.callsign AS flight_b FROM flight as a, flight as b WHERE a.dep_time \u0026gt; b.dep_time AND ST_ClosestPointOfApproach(a.geom, b.geom) IS NOT NULL; An abbreviated output would look like the following:\ntime | flight_a | flight_b -------------------------------+----------+---------- 2022-06-15 16:50:34.289124+02 | WSW209 | ROU1901 2022-06-15 16:13:25+02 | WSW209 | MAL8072 2022-06-15 16:13:25+02 | WSW209 | WJA209 2022-06-15 23:20:26+02 | ASP654 | WJA196 2022-06-15 23:16:29.999995+02 | ASP654 | FLE515 2022-06-15 23:01:11+02 | ASP654 | CGFHA 2022-06-15 23:11:15+02 | ASP654 | CL604KGN 2022-06-15 23:01:03+02 | ASP654 | CGBMO 2022-06-15 23:11:15+02 | ASP654 | ROU1902 2022-06-15 23:01:03+02 | ASP654 | CGBMO Let\u0026rsquo;s say we want to find instances where two aircraft were within 1000 metres of one another:\nWITH flights AS ( SELECT a.callsign AS fa, b.callsign AS fb, ST_Transform(a.geom, 3005) AS ga, ST_Transform(b.geom, 3005) AS gb FROM flight AS a, flight AS b WHERE a.dep_time \u0026gt; b.dep_time ), cpa AS ( SELECT fa, fb, ga, gb, ST_DistanceCPA(ga,gb) AS sd, ST_ClosestPointOfApproach(ga, gb) AS m FROM flights WHERE ST_ClosestPointOfApproach(ga, gb) IS NOT NULL ) SELECT m AS unix_time, round(sd) AS separation, fa AS flight_a, fb AS flight_b FROM cpa WHERE sd \u0026lt;= 1000; This gives us the following output, including one remarkable outlier where two planes were within just 31 metres of one another (at least as reported by the ADS-B data)!\nunix_time | separation | flight_a | flight_b --------------------+------------+----------+---------- 1655318221 | 782 | N90422 | N50KA 1655317602.2365394 | 31 | CGGGO | WEN3354 1655246393.916999 | 984 | CGVEA | CFSUV 1655253184.6499498 | 996 | CGLDP | JZA161 A separation of 31 metres is so small that it\u0026rsquo;s worth double checking the data to see what those two aircraft were doing at exactly 1655317602.2365394.\nSELECT ST_AsText(geom) FROM ( SELECT (ST_DumpPoints(flight.geom)).* FROM flight WHERE callsign = \u0026#39;CGGGO\u0026#39;) AS g; From the points in flight CGGGO, we see that there were ADS-B state vectors recorded two minutes before and 13 seconds after 1655317602, but no state vector exactly at 1655317602.\npath | st_astext ------+----------------------------------------------------------------- {1} | POINT ZM (1218224.1390170476 455564.6965150813 0 1655317419) {2} | POINT ZM (1218370.96000034 455381.88762515073 0 1655317425) {3} | POINT ZM (1218440.9541452834 455284.7816067032 0 1655317428) {4} | POINT ZM (1218456.977321602 455252.1045787118 0 1655317429) {5} | POINT ZM (1218559.022961798 455089.6465681435 0 1655317434) {6} | POINT ZM (1218582.8252591728 455046.18074272043 0 1655317436) {7} | POINT ZM (1218614.8748292197 454980.82785217743 0 1655317437) {8} | POINT ZM (1218623.5907024834 454947.84267283714 0 1655317438) {9} | POINT ZM (1218624.5285217932 454925.6466826303 0 1655317439) {10} | POINT ZM (1218634.1823688783 454870.46557313844 0 1655317440) {11} | POINT ZM (1218635.5891432345 454837.17162861006 0 1655317441) {12} | POINT ZM (1218636.5269924412 454814.975674214 0 1655317442) {13} | POINT ZM (1218632.4999741595 454736.98104434885 0 1655317444) {14} | POINT ZM (1218627.066055597 454692.2803657774 0 1655317445) {15} | POINT ZM (1218598.019306817 454513.16918261163 0 1655317450) {16} | POINT ZM (1218524.7346475082 453820.77799814986 0 1655317466) {17} | POINT ZM (1218516.20432238 453675.88890926924 0 1655317469) {18} | POINT ZM (1218497.63525764 453074.757360585 304 1655317482) {19} | POINT ZM (1218212.1383303064 445414.31268528895 609 1655317615) {20} | POINT ZM (1218196.3919528325 445091.2794655764 609 1655317620) {21} | POINT ZM (1218224.3295626454 442858.135926426 914 1655317663) {22} | POINT ZM (1218221.4493862633 441879.82805676176 914 1655317684) ... What PostGIS is doing is interpolating the coordinates when the exact measure value does not exist in the data set:\nWITH point AS ( SELECT callsign, ST_GeometryN(ST_LocateAlong(ST_Transform(a.geom, 3005), 1655317602.2365394), 1) AS pa FROM flight AS a WHERE a.callsign in (\u0026#39;CGGGO\u0026#39;, \u0026#39;WEN3354\u0026#39;) ) SELECT callsign, ST_AsText(ST_Force3DZ(pa), 0) AS position FROM point; Compare the results with the table above and you\u0026rsquo;ll see how the values fit between the two highlighted lines.\ncallsign | position ----------+------------------------------ CGGGO | POINT Z (1218240 446149 580) WEN3354 | POINT Z (1218249 446149 609) Apply a little Pythagorean theorem and the distance was, in fact, 31 metres. Well \u0026hellip; sort of. Because of gaps in the ADS-B data, all PostGIS can do is estimate where the planes actually were. But if those estimates were correct, then the rest of the math does, in fact, check out!\nThese are also sometimes called Mode-S codes.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nICAO 24 numbers are often found in upper case online, but most OpenSky API endpoints accept them only in lower case.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNote that the latitude/longitude ordering switches between the /states and /tracks endpoints!\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOne disadvantage, however, is that the function is tied to this table.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTraffic Collision Avoidance System.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 January 0001","permalink":"/pages/ads-b/","section":"Pages","summary":"ADS-B data\u003e ADS-B data # Can standard geospatial tools be used with transmissions from Automatic Dependent Surveillance-Broadcast (ADS-B) equipment aboard aircraft? I wanted to find out because unlike most geospatial data, ADS-B has a third dimension and a fourth dimension.","title":"Multidimensional data in PostGIS"},{"content":"","date":"1 January 0001","permalink":"/tags/ottoman/","section":"Tags","summary":"","title":"ottoman"},{"content":"\n","date":"1 January 0001","permalink":"/pages/","section":"Pages","summary":"","title":"Pages"},{"content":"","date":"1 January 0001","permalink":"/tags/postgis/","section":"Tags","summary":"","title":"postgis"},{"content":"","date":"1 January 0001","permalink":"/tags/postgres/","section":"Tags","summary":"","title":"postgres"},{"content":"","date":"1 January 0001","permalink":"/tags/postgresql/","section":"Tags","summary":"","title":"postgresql"},{"content":"","date":"1 January 0001","permalink":"/tags/python/","section":"Tags","summary":"","title":"python"},{"content":"I authored two Python modules that make it easier to use geospatial Python from within your PostgreSQL database.\nplpygis\u003e plpygis # plpygis is a Python conveter to and from the PostGIS geometry type, WKB, EWKB, GeoJSON and Shapely geometries and additionally supports __geo_interface__. plpygis is intended for use in PL/Python functions, making the entire Python geospatial ecosystem available in SQL queries.\nA simple Python function using plpygis would be:\nCREATE OR REPLACE FUNCTION swap(geom geometry) RETURNS geometry AS $$ # swaps the x and y coordinates of a point from plpygis import Geometry, Point old_point = Geometry(geom) new_point = Point([old_point.y, old_point.x]) return new_point $$ LANGUAGE plpython3u; The magic happens with Geometry(geom), which is automatically converts from PostGIS\u0026rsquo;s geometry type, and the return statement, which automatically converts back to a PostGIS geometry.\nThe function above can be called with a normal SQL statement:\nSELECT swap(geom) FROM city; I spoke about plpygis at FOSS4G 2017 in Boston. The slides are here and a video of the talk is also available.\nDocumentation Source code geofdw\u003e geofdw # geofdw is a collection of PostGIS-related foreign data wrappers for PostgreSQL written in Python using the multicorn extension. By using a FDW, you can access spatial data through Postgres tables without having to import the data first, which can be useful for dynamic or non-tabular data available through web services.\nSource code ","date":"1 January 0001","permalink":"/pages/python-postgis/","section":"Pages","summary":"I authored two Python modules that make it easier to use geospatial Python from within your PostgreSQL database.\nplpygis\u003e plpygis # plpygis is a Python conveter to and from the PostGIS geometry type, WKB, EWKB, GeoJSON and Shapely geometries and additionally supports __geo_interface__.","title":"Python for PostGIS"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"1 January 0001","permalink":"/tags/syriac/","section":"Tags","summary":"","title":"syriac"},{"content":"","date":"1 January 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"1 January 0001","permalink":"/tags/z3/","section":"Tags","summary":"","title":"z3"}]