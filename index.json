[{"content":" Primary sources on Syriacs of Ottoman Adıyaman The linked monograph is a transcription Ottoman Turkish into the Latin alphabet of texts relating to the Syriac (Süryânî) community in Adıyaman and its environs. The document is composed of two parts, first being Adıyaman Tarihi, a manuscript written in Syria in the mid-twentieth century. The second part is a collection of articles collected from early-twentieth century Syriac newspapers in both the Ottoman Empire and the United States. All of the above were written in Syro-Ottoman (Ottoman Turkish using the Syriac alphabet) and the transcription reflects the original language. Notably, Adıyaman Tarihi exhibits many non-standard grammatical and orthographic practices, and these have been faithfully preserved here. The document also contains a glossary of Ottoman and Adıyaman dialectal terms so that the texts can be read by modern-day Turkish speakers.\nAdıyaman Tarihi\u003e Adıyaman Tarihi # Adıyaman Tarihi is one of the most remarkable works I have had the pleasure of working on: a first-hand account of the lives of the Syriac population in the Ottoman town of Adıyaman (also known as Hısn-ı Mansûr) during the late Ottoman Empire. The author escapes the local massacres with his life, but in light of ongoing post-war persecution, he eventually flees to mandate Syria, where he would spend the rest of his life.\nPage from Adıyaman Tarihi I gave a talk on the text during SAYFO 1915: An International Conference on the Genocide of Assyrians/Arameans during the First World War held at Freie Universität Berlin in 2015.\nInternational Conference: Seyfo 1915\nA map from the text was also featured on the lovely The Afternoon Map blog devoted to Ottoman and Ottoman-adjacent cartography.1\nAdıyamanlı Süryânîler is available under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. Download Another map I submitted is available as a post entitle The New Assyria.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 January 0001","permalink":"/pages/adiyaman/","section":"Pages","summary":"Primary sources on Syriacs of Ottoman Adıyaman The linked monograph is a transcription Ottoman Turkish into the Latin alphabet of texts relating to the Syriac (Süryânî) community in Adıyaman and its environs.","title":"Adıyamanlı Süryânîler"},{"content":"","date":"1 January 0001","permalink":"/tags/ads-b/","section":"Tags","summary":"","title":"ads-b"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":" An Ottoman constructed language World-famous constructed languages range from Zamenhof\u0026rsquo;s Esperanto to Tolkien\u0026rsquo;s Quenya to hobbyist \u0026ldquo; conlangs\u0026rdquo;, but isn\u0026rsquo;t it surprising to learn that centuries before them, an Ottoman in Egypt created his own language and that a thorough grammar and lexicon survives to this day?\nConlanging before it became cool was the scholar and mystic Mehmed ibn Fethullah ibn Ebü Tâlib, born in Edirne in the mid-16th century and spending the majority of his life in Ottoman Cairo.\nI started writing an English-language overview of Bāla’y-balan\u0026rsquo;s grammar based on both the original text as preserved in Princeton University\u0026rsquo;s library and a modern Turkish translation by Mustafa Koç, Bâleybelen. Muhyî-i Gülşenî. İlk Yapma Dil.\nA page from Kitâb-ı Bâleybelen The \u0026ldquo;full\u0026rdquo; PDF is available for download, but here are a few short excerpts:\nWords in Bāla’y-balan are not required to have vowel harmony, a distinguishing feature of the Turkish language. Words such as qaydak kapı \u0026lsquo;door, gate\u0026rsquo;, which has both a back q and a front k, would not be possible in a pure Turkish word. This point has further significance when we consider Bāla’y-balan’s suffixes, which will not harmonise with the vowels in the root to which they are attached.\nThe Bāla’y-balan plural is created by the addition of the suffix -ā: نو niv \u0026lsquo;flower\u0026rsquo; and نوا nivā \u0026lsquo;flowers\u0026rsquo;. When the base noun already ends with a -ā, then -y- is added as a buffer between the two vowels. When the base noun ends in the vowel ه [a], then the long ā is added, and the ه is vocalised with its consonontal value [h]: ظفه ẓafa \u0026lsquo;book\u0026rsquo;, ظفها ẓafahā.\nA noun may be placed in accusative case by the addition of the suffix -rā. This may be added to both singular and plural nouns: شَمْسَا نِوَارَا Şamsā nivārā \u0026lsquo;They smelled the flowers\u0026rsquo;.\nBāla’y-balan is available under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. Download ","date":"1 January 0001","permalink":"/pages/balaybalan/","section":"Pages","summary":"An Ottoman constructed language World-famous constructed languages range from Zamenhof\u0026rsquo;s Esperanto to Tolkien\u0026rsquo;s Quenya to hobbyist \u0026ldquo; conlangs\u0026rdquo;, but isn\u0026rsquo;t it surprising to learn that centuries before them, an Ottoman in Egypt created his own language and that a thorough grammar and lexicon survives to this day?","title":"Bāla’y-balan"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/tags/geospatial/","section":"Tags","summary":"","title":"geospatial"},{"content":"","date":"1 January 0001","permalink":"/tags/history/","section":"Tags","summary":"","title":"history"},{"content":"","date":"1 January 0001","permalink":"/","section":"jaxartes.net","summary":"","title":"jaxartes.net"},{"content":"","date":"1 January 0001","permalink":"/tags/language/","section":"Tags","summary":"","title":"language"},{"content":" An Ottoman Turkish tautology Wikipedia has an article on a place called Pendle Hill, noteworthy, perhaps, mainly for being a triple tautology:\nThe name \u0026ldquo;Pendle Hill\u0026rdquo; combines the words for hill from three different languages \u0026hellip; In the 13th century it was called Pennul or Penhul, apparently from the Cumbric pen and Old English hyll, both meaning \u0026ldquo;hill\u0026rdquo;. The modern English \u0026ldquo;hill\u0026rdquo; was appended later, after the original meaning of Pendle had become opaque.\nThis reminded me of a similar triple tautology I came across as a graduate student reading copies of a monthly journal from the early twentieth century.\nMürşid-i Âsûriyûn, May 1912 Reading right-to-left, you can see it right there at the start of the second line: ܔܒܠܛܘܪ ܛܐܓ݂ . That\u0026rsquo;s cebel (Arabic for \u0026ldquo;mountain\u0026rdquo;), tûr (Syriac for \u0026ldquo;mountain\u0026rdquo;) and dağ (Turkish for, you guessed it, \u0026ldquo;mountain\u0026rdquo;).1\nThe text above was written in Ottoman Turkish, and for consistency, I am using standard Turkish transliteration for all the foreign language words. It\u0026rsquo;s worth pointing out that cebel is pronounced \u0026ldquo;jebel\u0026rdquo;. The \u0026ldquo;mountain\u0026rdquo; in question here was actually the Tur Abdin region in modern Turkey, ironically a region that has no mountains and can be described as hilly at best.\nAs a small aside, the journal Mürşid-i Âsûriyûn that this place name came from is interesting a in a few ways:\nIf the image above looks handwritten, that\u0026rsquo;s because it was. The publisher, Âşûr Yûsuf, printed copies using a technique called mimeography. The journal existed between 1909 and 1914 in the ancient city of Harpût, then a provincial capital and was mailed to subscribers across the Ottoman Empire and as far away as the United States. This preserved copy comes from a subscriber in Massachusetts. Ottoman Turkish was usually written using the Arabic alphabet, but Âşûr Yûsuf used the Syriac alphabet in Mürşid-i Âsûriyûn. This was the first journal to be printed in Ottoman Turkish with Syriac letters, but it was followed by several more. You could still find them being published in Lebanon and the United States into the 1930s. Syriac Arabic Latin ܔܒܠ جبل cebel ܛܘܪ طور tûr ܛܐܓ݂ طاغ dağ Âşûr Yûsuf was a native speaker of Armenian and he did not know the Syriac language, despite identifying as a Syriac (Süryânî) and an Assyrian (Âsûrî). Like any other speaker of Ottoman Turkish, he would have been well-acquainted with the common word cebel despite not speaking Arabic himself.\nIt\u0026rsquo;s interesting to compare his usage to some other notable topological features in the Ottoman Empire:\nMount Sinai is جبل الطور (Cebel et-Tûr) in Arabic and was جبل طور (Cebel‑i Tûr) in Ottoman Turkish.2 The Mount of Olives near Jerusalem was also Cebel‑i Tûr (although it is simply الطور in Arabic). Mount Gerizim near Nablus is another Cebel et-Tûr. In the Arabic and the Ottoman cases where we find both cebel and tûr, speakers would have understood these names to mean something like \u0026ldquo;Tûr Mountain\u0026rdquo;.\nWhen I originally read the passage above, I also transliterated the place name as Cebel‑i Tûr Dağı, but looking at the text again, I can see that the author intended it to be read Cebeltûr Dağı. My original reading would have required a space between the first two words, so ܔܒܠ ܛܘܪ ܛܐܓ݂ , but that space is quite clearly not there: ܔܒܠܛܘܪ ܛܐܓ݂ .\nAnd that, I suppose, is the difference. Cebel-i Tûr (with a space) was \u0026ldquo;Mount Tûr\u0026rdquo; and no Dağ was necessary or even possible. But Cebeltûr (no space) had become a set phrase much like Penhul. And it was acceptable for a Turkish-speaker to call this place Cebeltûr Dağı: \u0026ldquo;Mount Cebeltûr\u0026rdquo;.\nObservant readers will note that it is actually ܔܒܠܛܘܪ ܛܐܓ݂ܢܢ in the original text but the final two characters are the Turkish grammatical suffix -ının which we can ignore.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIn Turkish today, Tûr Dağı has replaced the Persian grammatical construct which you see in Cebel-i Tûr. And both now and then, Mount Sinai had many different names, including Cebel-i Sînâ.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 January 0001","permalink":"/pages/mt-mountain-mountain/","section":"Pages","summary":"An Ottoman Turkish tautology Wikipedia has an article on a place called Pendle Hill, noteworthy, perhaps, mainly for being a triple tautology:\nThe name \u0026ldquo;Pendle Hill\u0026rdquo; combines the words for hill from three different languages \u0026hellip; In the 13th century it was called Pennul or Penhul, apparently from the Cumbric pen and Old English hyll, both meaning \u0026ldquo;hill\u0026rdquo;.","title":"Mount Mountain Mountain"},{"content":"ADS-B data\u003e ADS-B data # Can standard geospatial tools be used with transmissions from Automatic Dependent Surveillance-Broadcast (ADS-B) equipment aboard aircraft? I wanted to find out because unlike most geospatial data, ADS-B has a third dimension and a fourth dimension.\nMy geospatial analysis tool of choice is PostGIS, which has multidimensional geometry types and functions, but I had never really had cause to use them despite having coded support for additional dimensions when I developed plpygis.\nThis article describes the process of getting free ADS-B data, loading it into PostgreSQL and then manipulating it with PostGIS and Python.\nTools\u003e Tools # In addition to PostgreSQL and PostGIS, I used two Python modules: requests and plpygis. These must be installed in a location from which PostgreSQL’s PL/Python can import them. I also used QGIS for visualization.\nAircraft identities\u003e Aircraft identities # Step one was learning about ICAO 24 addresses, unique aircraft identifiers which are included in every ADS-B transmission.1 These are 24-bit values represented by a six-digit hexadecimal number, such as A4DA1. These codes are distinct from the registration numbers that are visible on an aircraft\u0026rsquo;s body or tail.\nUzbekistan Airways IL-76 with registration UK-76428 A single physical aircraft may have multiple ICAO 24 addresses over its lifetime but these change much less frequently than registration numbers.\nDrukair ATR-42 with the registration number A5-RGH (via www.planespotters.net) The ATR-42 in the image above has moved between three airlines and therefore been registered under three different numbers … but also with two different ICAO 24 codes, 3a2270 and 39ad00. The history of these alterations can be found in some databases, such as the one maintained by Planespotters.net.\nThe OpenSky Network\u003e The OpenSky Network # The The OpenSky Network provides free access to ADB-S data via a RESTful API. There is a Python client, but I did not use it since it doesn’t implement everything that is available directly through the API.\nAn ICAO 24 address2 is the basis for most OpenSky API calls, although it is possible to request data by searching for activity at a particular airport or region.\nI created a free OpenSky account since the API documentation states that the rate limits are stricter for anonymous users. And although my experience is that the API behaviour does not always match the documentation, it seemed like a good idea to do what they recommend in this case.\nState vectors\u003e State vectors # Equipped with an ICAO 24 number, I retrieved some actual flight data provided by OpenSky. A basic query also requires a specific time, with that time being represented as the number of seconds elapsed since the 1st of January 1970 (otherwise known as UNIX time). For example, the position of the ATR-42 above at 16:01:23 on the 11th of April, 2022 is requested by https://opensky-network.org/api/states/all?icao24=39ad00\u0026time=1649692883.\nThe JSON-encoded response looks like the following:\n{ \u0026#34;time\u0026#34;: 1649692883, \u0026#34;states\u0026#34;: [ [ \u0026#34;39ad00\u0026#34;, \u0026#34;AFR57AG \u0026#34;, \u0026#34;France\u0026#34;, 1649692879, 1649692882, 2.5172, 44.9426, 2263.14, false, 100.86, 24.08, 10.08, null, 2316.48, null, false, 0 ] ] } The data transmitted by the aircraft is stored in the list of states and can be decoded through the OpenSky documentation. From this you know that the aircraft was operating as Air France 57AG, that it recorded a barometric altitude of 2263.14 meters, that it had a ground speed of 100.86 meters/second and so on.\nBack to my Il-76 in Tashkent, planefinder tells me that the ICAO 24 code associated with UK-76428 is 507f87. As it turns out, OpenSky doesn’t have any records of that particular airplane flying, which is, I suppose, an answer to my original question of what these planes might be up to: not much, or at least not much in the range of a receiver operated by someone participating in the OpenSky Network. But there are plenty of other planes in the sky to look at!\nTracks\u003e Tracks # OpenSky simplifies getting a series of state vectors by providing a tracks API endpoint, and although the documentation states that this endpoint is experimental, I’ve had success in using it: https://opensky-network.org/api/tracks/?icao24=39ad00\u0026time=1649692883.\nThe response to the request above will contain some basic facts about the flight, including the first and last times at which it was observed:\n{ \u0026#34;icao24\u0026#34;: \u0026#34;39ad00\u0026#34;, \u0026#34;callsign\u0026#34;: \u0026#34;AFR57AG \u0026#34;, \u0026#34;startTime\u0026#34;: 1649692883, \u0026#34;endTime\u0026#34;: 1649696435, \u0026#34;path\u0026#34;: [...] } The path element is a list of abbreviated state vectors showing the route the aircraft took on this flight. One of these vectors might look like the following:\n[ 1649693075, 45.129, 2.631, 3352, 23, false ] These values are the time, latitude, longitude, barometric altitude, heading and whether the aircraft is on the ground respectively.3\nThe one significant limitation with OpenSky is that these flight tracks are only available for flights from the last 30 days.\nFlights\u003e Flights # The next endpoint that we’ll be using is /flights/aircraft, which lists all the flights taken by an aircraft: https://opensky-network.org/api/flights/aircraft/?icao24=39ad00\u0026begin=1609455600\u0026end=1609714800.\nOne flight in the list looks like the following:\n{ \u0026#34;icao24\u0026#34;: \u0026#34;39ad00\u0026#34;, \u0026#34;firstSeen\u0026#34;: 1649692883, \u0026#34;estDepartureAirport\u0026#34;: \u0026#34;LFLW\u0026#34;, \u0026#34;lastSeen\u0026#34;: 1649696438, \u0026#34;estArrivalAirport\u0026#34;: \u0026#34;LFPO\u0026#34;, \u0026#34;callsign\u0026#34;: \u0026#34;AFR57AG \u0026#34;, \u0026#34;estDepartureAirportHorizDistance\u0026#34;: 9750, \u0026#34;estDepartureAirportVertDistance\u0026#34;: 1654, \u0026#34;estArrivalAirportHorizDistance\u0026#34;: 3750, \u0026#34;estArrivalAirportVertDistance\u0026#34;: 33, \u0026#34;departureAirportCandidatesCount\u0026#34;: 0, \u0026#34;arrivalAirportCandidatesCount\u0026#34;: 9 } The departure and arrival airports are estimates since these are not explicitly reported by the ADB-S data, so OpenSky infers them from what it observes; on occasion you will see an airport listed as null when there wasn’t enough data to establish what the plane’s origin or destination were.\nAny time between firstSeen and lastSeen can be used with the /tracks endpoint above to get the entire path that the plane took on this flight.\nAirport activity\u003e Airport activity # Two final endpoints that are interesting are /flights/arrival and /flights/departure, which will list all the flights that terminate or originate at a particular airport between two points in time.\nADS-B data in PostGIS\u003e ADS-B data in PostGIS # Database creation\u003e Database creation # Once PostgreSQL and PostGIS are installed and your user has the right privileges, you can run the following on the command line:\ncreatedb opensky Then open the database to interact with it:\npgsql opensky You first need to enable PostGIS:\nCREATE EXTENSION postgis; Create the table to store the flight data:\nCREATE TABLE flight ( icao24 TEXT, callsign TEXT, dep_airp TEXT, -- departure airport arr_airp TEXT, -- arrival airport dep_time TIMESTAMP, -- departure time arr_time TIMESTAMP, -- arrival time geom GEOMETRY(LINESTRINGZM, 4326) ); The geometry type LINESTRINGZM means that each vertex in the path will have four dimensions: x and y (longitude and latitude), z (altitude) and m (the “measure” value, which will be used for time).\nFinally, add an index but make it n-dimensional, which optimizes queries across all four dimensions.\nCREATE INDEX ON flight USING gist (geom gist_geometry_ops_nd); PL/Python\u003e PL/Python # There are a few ways to bring the data from the OpenSky API into the database, but I used PL/Python, which means we’ll write a function in Python that will be run from inside the database. To make it easier to work with PostGIS, I also used plpygis, a small Python module that I created to help write PL/Python functions for geospatial data.\nStart by enabling PL/Python:\nCREATE LANGUAGE plpython3u; Let’s start with a simple function that gets a list of flights an aircraft took between two dates.\nCREATE OR REPLACE FUNCTION get_aircraft_flights(icao24 TEXT, in_datebegin DATE, in_dateend DATE) RETURNS TABLE (LIKE flight) AS $$ OSUSER = \u0026#39;YOUR_USERNAME\u0026#39; OSPW = \u0026#39;YOUR_PASSWORD\u0026#39; OSURL = \u0026#34;https://opensky-network.org/api\u0026#34; from datetime import datetime from dateutil import parser from requests import Session from requests.auth import HTTPBasicAuth db = parser.parse(in_datebegin) de = parser.parse(in_dateend).replace(hour=23, minute=59) db = int(db.timestamp()) de = int(de.timestamp()) opensky = Session() opensky.auth = HTTPBasicAuth(OSUSER, OSPW) res = opensky.get( OSURL + \u0026#34;/flights/aircraft/\u0026#34;, params={\u0026#34;icao24\u0026#34; : icao24, \u0026#34;begin\u0026#34; : db, \u0026#34;end\u0026#34; : de}) if res.status_code == 200 and res.text: plpy.info(res.request.url) flights = [(icao24, f[\u0026#34;callsign\u0026#34;].strip() if f[\u0026#34;callsign\u0026#34;] else \u0026#34;\u0026#34;, f[\u0026#34;estDepartureAirport\u0026#34;], f[\u0026#34;estArrivalAirport\u0026#34;], datetime.fromtimestamp(f[\u0026#34;firstSeen\u0026#34;]), datetime.fromtimestamp(f[\u0026#34;lastSeen\u0026#34;]), None) for f in res.json()] return flights else: plpy.info(res.request.url, res.status_code, res.text) return [] $$ LANGUAGE plpython3u; The function definition get_aircraft_flights takes three arguments, the ICAO 24 code discussed above plus a start and an end date. Returning TABLE (LIKE flight) is a rather useful way that PostgreSQL lets you force the output of a function to match exactly the definition of a table.4\nThe function makes a call to the OpenSky API to get all the flights for the aircraft between the two dates, and returns the results. It does not fill in the track for each flight, but we can write another function to do that:\nCREATE OR REPLACE FUNCTION get_track(icao24 TEXT, in_date TIMESTAMP WITH TIME ZONE) RETURNS GEOMETRY(LINESTRINGZM, 4326) AS $$ OSUSER = \u0026#39;YOUR_USERNAME\u0026#39; OSPW = \u0026#39;YOUR_PASSWORD\u0026#39; OSURL = \u0026#34;https://opensky-network.org/api\u0026#34; from datetime import datetime from dateutil import parser from requests import Session from requests.auth import HTTPBasicAuth from plpygis import LineString dt = parser.parse(in_date) dt = int(dt.timestamp()) opensky = Session() opensky.auth = HTTPBasicAuth(OSUSER, OSPW) res = opensky.get( OSURL + \u0026#34;/tracks/\u0026#34;, params={\u0026#34;icao24\u0026#34; : icao24.lower(), \u0026#34;time\u0026#34; : dt}) if res.status_code == 200 and res.text: plpy.info(res.request.url) fl = res.json() return LineString( [[v[2], v[1], v[3], v[0]] for v in fl[\u0026#34;path\u0026#34;]]) else: plpy.info(res.request.url, res.status_code, res.text) return None $$ LANGUAGE plpython3u; Now you can use SQL on the results of this function as if it were a normal database table. For example if you want to know all the unique flight numbers flown by 39ad00 in the first week of May, you can query the OpenSky API like this:\nSELECT DISTINCT callsign FROM get_aircraft_flights(\u0026#39;c05f01\u0026#39;, \u0026#39;2022-05-01\u0026#39;, \u0026#39;2022-05-07\u0026#39;); callsign ---------- JZA653 JZA652 JZA270 JZA283 JZA651 JZA161 JZA399 JZA300 JZA157 JZA460 JZA801 JZA349 JZA279 JZA322 JZA658 JZA164 JZA282 JZA153 JZA156 JZA295 JZA147 JZA400 JZA810 JZA800 JZA654 JZA803 JZA160 JZA459 One issue that you will observe doing the above is that you are pulling data from the API with every query. It will be much better to have a local copy of the data to work with:\nINSERT INTO flight SELECT * FROM get_aircraft_flights(\u0026#39;c05f01\u0026#39;, \u0026#39;2022-05-01\u0026#39;, \u0026#39;2022-05-07\u0026#39;); Now the same queries can be run locally from our flight table:\nSELECT DISTINCT callsign FROM flight; And how do we add the tracks?\nUPDATE flight SET geom = get_track(icao24, dep_time) WHERE date(dep_time) = \u0026#39;2022-05-01\u0026#39;; Remove the WHERE clause and you’ll add tracks to all the flights in your table (which could take a very long time depending on what you have put in there). To add geometries to all the flights without them, you can change the where clause to WHERE geom IS NULL.\nAnd, of course, you can hook the table up to QGIS to see those flight paths.\nFlight tracks rendered in QGIS Geospatial queries\u003e Geospatial queries # With the data in PostGIS, let’s do some analysis.\nLet’s start easy and say that you want to know how many kilometers 39ad00 flew on the 1st of May:\nSELECT count(*) AS flights, SUM(ST_Length(geom::geography)) / 1000 AS distance FROM flight WHERE date(dep_time) = \u0026#39;2022-05-01\u0026#39;; flights | distance ---------+------------------- 5 | 1499.689291267288 A little more advanced is seeing how often 39ad00 flew between two Canadian airports but travelled over the landmass of the United States to get there. To do this, I downloaded the administrative boundaries data set from NaturalEarth and after unzipping it, I loaded it into the opensky database:\nshp2pgsql -s 4326 -g geom ne_10m_admin_0_countries.shp country | psql opensky And the I ran the following query to find instances when the start and end of a flight were in Canada but at some point the flight path intersected with US territory:\nSELECT f.callsign, f.dep_time, f.dep_airp, f.arr_airp FROM flight AS f, country AS usa, country AS canada WHERE usa.name = \u0026#39;United States of America\u0026#39; AND canada.name = \u0026#39;Canada\u0026#39; AND ST_Intersects(canada.geom, ST_StartPoint(f.geom)) AND ST_Intersects(canada.geom, ST_EndPoint(f.geom)) AND ST_Intersects(usa.geom, f.geom); callsign | dep_time | dep_airp | arr_airp ----------+---------------------+----------+---------- JZA474 | 2022-05-13 01:10:16 | CYCD | CYYC Showing that particular flight in QGIS, we can see how it did, in fact, pass over the United States during its flight.\nJazz Air flight 474 crossed Washington state on its departure from Nanaimo Going multidimensional\u003e Going multidimensional # Crossed Paths\u003e Crossed Paths # With some data in our flight table, we can do multidimensional analysis using three dimensions as described in the PostGIS documentation.\nLet\u0026rsquo;s start by seeing if any of the flights had an exact intersections of their flight paths.\nSELECT a.callsign, a.dep_time, b.callsign, b.dep_time, ST_AsText(ST_Intersection(a.geom, b.geom)) FROM flight AS a, flight AS b WHERE a.dep_time \u0026gt; b.dep_time AND ST_Intersects(ST_Force3D(a.geom), ST_Force3D(b.geom)); Note that we are forcing the geometries to be three-dimensional and not four-dimensional. A two-dimentional intersection would ignore altitude completely, while a four-dimensional intersection would be asking for two planes that crossed paths at the exact same point at the exact same time, otherwise known as a mid-air collision.\nAmong the results is something like this, where we can see the exact three-dimensional point at which the paths of Jazz Air flights 168 and 150 intersected one another.\nJZA168 | 2022-06-07 04:49:17 | JZA150 | 2022-06-06 18:15:24 | POINT Z (-123.28160909937012 48.72753520085094 609) The intersection point is expressed in three-dimensional WKT, POINT Z (-123.28160909937012 48.72753520085094 609), where the 609 indicates that the planes were at an altitude of 609 metres or about 2000 feet, a reasonable altitude for planes on approach to an airport.\nFlight tracks for JZA168 and JZA150 crossing paths Click here to see the 3d model above (vertical scale has been exaggerated).\nFour dimensions\u003e Four dimensions # Closest points of approach\u003e Closest points of approach # A four-dimensional intersection is a mid-air collision, and Canada\u0026rsquo;s Civil Aviation Daily Occurrence Reporting System has a queryable database of \u0026ldquo;occurrences\u0026rdquo; on the Transport Canada website. By filtering on the string \u0026ldquo;TCAS\u0026rdquo;5, I found the following incident:\nUPDATE: TSB Report #A22O0076: C-FAXD, a Boeing 737 MAX 8 aircraft operated by Sunwing Airlines Inc, was conducting flight SWG443 from Punta Cana International Airport (PUJ/MDPC), Dominican Republic, to Toronto Pearson International Airport (CYYZ), ON. While on final approach into CYYZ for Runway 33L, the flight crew received a Traffic Alert and Collision Avoidance System (TCAS) resolution advisory (RA) with C-GJVT, an Airbus 320-200 aircraft operated by Air Canada conducting flight ACA264 from Winnipeg/James Armstrong Richardson International Airport (CYWG), MB, to CYYZ, which was on final approach for Runway 33R. SWG443 followed the TCAS RA and aborted the approach to the left. Both aircraft came to a minimum lateral separation of 0.6 Nautical Miles and a minimum vertical separation of 500 feet. SWG443 was at an altitude of 3500 feet and ACA264 at 3000 feet, abeam to each other, on approach for Runways 33L and 33R. SWG443 and ACA264 landed without further incident.\nI wanted to see if I could replicate this narrative in ADS-B data. The first problem is that all the data in the flight table comes from the same airplane, so I added a new function that ingests all the tracks arriving or departing from a specific airport.\nCREATE OR REPLACE FUNCTION get_airport_flights(airport TEXT, in_datebegin DATE, in_dateend DATE) RETURNS TABLE (LIKE flight) AS $$ OSUSER = \u0026#39;YOUR_USERNAME\u0026#39; OSPW = \u0026#39;YOUR_PASSWORD\u0026#39; OSURL = \u0026#34;Thttps://opensky-network.org/api\u0026#34; from datetime import datetime from dateutil import parser from requests import Session from requests.auth import HTTPBasicAuth db = parser.parse(in_datebegin) de = parser.parse(in_dateend).replace(hour=23, minute=59) db = int(db.timestamp()) de = int(de.timestamp()) opensky = Session() opensky.auth = HTTPBasicAuth(OSUSER, OSPW) for endpoint in [\u0026#34;arrival\u0026#34;, \u0026#34;departure\u0026#34;]: res = opensky.get( OSURL + \u0026#34;/flights/{}/\u0026#34;.format(endpoint), params={\u0026#34;airport\u0026#34; : airport, \u0026#34;begin\u0026#34; : db, \u0026#34;end\u0026#34; : de}) if res.status_code == 200 and res.text: plpy.info(res.request.url) for f in res.json(): if not f[\u0026#34;firstSeen\u0026#34;] or not f[\u0026#34;lastSeen\u0026#34;]: continue yield (f[\u0026#34;icao24\u0026#34;], f[\u0026#34;callsign\u0026#34;].strip() if f[\u0026#34;callsign\u0026#34;] else \u0026#34;\u0026#34;, f[\u0026#34;estDepartureAirport\u0026#34;], f[\u0026#34;estArrivalAirport\u0026#34;], datetime.fromtimestamp(f[\u0026#34;firstSeen\u0026#34;]), datetime.fromtimestamp(f[\u0026#34;lastSeen\u0026#34;]), None) else: plpy.info(res.request.url, res.status_code, res.text) $$ LANGUAGE plpython3u; I populated it with the flights to and from CYYZ on the date of the incident.\nCREATE TABLE tcas (LIKE flight); INSERT INTO tcas SELECT * FROM get_airport_flights(\u0026#39;CYYZ\u0026#39;, \u0026#39;2022-06-18\u0026#39;, \u0026#39;2022-06-18\u0026#39;); I could have ingested all the tracks for every row in the table, but since I already knew the affected flights, I just focused on those.\nUPDATE tcas SET geom = get_track(icao24, dep_time) WHERE callsign IN (\u0026#39;ACA264\u0026#39;, \u0026#39;SWG443\u0026#39;); After adding the tracks, the PostGIS function ST_ClosestPointOfApproach can tell us where along the timelines of two flights are they at their closest proximity. We will, however, want to have the geometry reprojected into a spatial reference system that makes distance calculations using metres - not latitude and longitude - since that is what the altitude is measured in. Since the data set is clustered around Victoria, EPSG:7991 is a good choice.\nST_ClosestPointOfApproach finds the measure value at which two tracks are closest to one another. ST_DistanceCPAprovides the actual three-dimensional distance between the two tracks at this closest point of approach.\nWITH flights AS ( SELECT a.callsign AS fa, b.callsign AS fb, ST_Transform(a.geom, 7991) AS ga, ST_Transform(b.geom, 7991) AS gb FROM tcas AS a, tcas AS b WHERE a.callsign = \u0026#39;ACA264\u0026#39; AND b.callsign = \u0026#39;SWG443\u0026#39; ), cpa AS ( SELECT fa, fb, ga, gb, ST_ClosestPointOfApproach(ga, gb) AS m FROM flights ), points AS ( SELECT fa, fb, ST_Force3DZ(ST_GeometryN(ST_LocateAlong(ga, m), 1)) AS pa, ST_Force3DZ(ST_GeometryN(ST_LocateAlong(gb, m), 1)) AS pb, ST_DistanceCPA(ga, gb) AS distance, m FROM cpa ) SELECT to_timestamp(m) AT TIME ZONE \u0026#39;UTC\u0026#39; AS time, round(distance) AS separation, round(ST_Distance(ST_Force2D(pa), ST_Force2D(pb))) AS lateral_separation, round(abs(ST_Z(pa) - ST_Z(pb))) AS vertical_separation, fa AS a, fb AS b, ST_AsText(ST_Transform(pa, 4326), 3) AS a_position, ST_AsText(ST_Transform(pb, 4326), 3) AS b_position FROM points; According to Transport Canada, the lateral separation at 22:39 UTC should be 0.6 nautical miles, which is is 1111 metres, and the vertical separation should be approximately 500 feet. The ADS-B data doesn\u0026rsquo;t exactly replicate those findings but it\u0026rsquo;s not hugely far off.\ntime | separation | lateral_separation | vertical_separation | a | b | a_position | b_position ---------------------+------------+--------------------+---------------------+--------+--------+----------------------------------+------------------------------ 2022-06-18 22:38:07 | 1119 | 1075 | 310 | ACA264 | SWG443 | POINT Z (-79.448 43.542 604.234) | POINT Z (-79.457 43.536 914) The altitude of the two flights does not match the altitudes stated by Transport Canada; however, the altitude reported by these two aircraft on the ground at Toronto was 0, so adding ~170m to account for the airport\u0026rsquo;s elevation does bring us into that range.\nFlight tracks for ACA264 and SWG443 and their positions when at their closest Searching for near misses\u003e Searching for near misses # Lastly, I wanted to see if there were any \u0026ldquo;close calls\u0026rdquo; like the one above that were not reported in the Transport Canada database.\nLet\u0026rsquo;s load the in-bound and out-bound flights at Victoria International Airport (YYJ) on a single day:\nINSERT INTO flight SELECT * FROM get_airport_flights(\u0026#39;CYYJ\u0026#39;, \u0026#39;2022-06-15\u0026#39;, \u0026#39;2022-06-15\u0026#39;); From this we will see for all flights that have any temporal overlap, there is a single time at which the two flights were closest to one another.\nSELECT to_timestamp(ST_ClosestPointOfApproach(ST_Transform(a.geom, 3005), ST_Transform(b.geom, 3005))) AS time, a.callsign AS flight_a, b.callsign AS flight_b FROM flight as a, flight as b WHERE a.dep_time \u0026gt; b.dep_time AND ST_ClosestPointOfApproach(a.geom, b.geom) IS NOT NULL; An abbreviated output would look like the following:\ntime | flight_a | flight_b -------------------------------+----------+---------- 2022-06-15 16:50:34.289124+02 | WSW209 | ROU1901 2022-06-15 16:13:25+02 | WSW209 | MAL8072 2022-06-15 16:13:25+02 | WSW209 | WJA209 2022-06-15 23:20:26+02 | ASP654 | WJA196 2022-06-15 23:16:29.999995+02 | ASP654 | FLE515 2022-06-15 23:01:11+02 | ASP654 | CGFHA 2022-06-15 23:11:15+02 | ASP654 | CL604KGN 2022-06-15 23:01:03+02 | ASP654 | CGBMO 2022-06-15 23:11:15+02 | ASP654 | ROU1902 2022-06-15 23:01:03+02 | ASP654 | CGBMO Let\u0026rsquo;s say we want to find instances where two aircraft were within 1000 metres of one another:\nWITH flights AS ( SELECT a.callsign AS fa, b.callsign AS fb, ST_Transform(a.geom, 3005) AS ga, ST_Transform(b.geom, 3005) AS gb FROM flight AS a, flight AS b WHERE a.dep_time \u0026gt; b.dep_time ), cpa AS ( SELECT fa, fb, ga, gb, ST_DistanceCPA(ga,gb) AS sd, ST_ClosestPointOfApproach(ga, gb) AS m FROM flights WHERE ST_ClosestPointOfApproach(ga, gb) IS NOT NULL ) SELECT m AS unix_time, round(sd) AS separation, fa AS flight_a, fb AS flight_b FROM cpa WHERE sd \u0026lt;= 1000; This gives us the following output, including one remarkable outlier where two planes were within just 31 metres of one another (at least as reported by the ADS-B data)!\nunix_time | separation | flight_a | flight_b --------------------+------------+----------+---------- 1655318221 | 782 | N90422 | N50KA 1655317602.2365394 | 31 | CGGGO | WEN3354 1655246393.916999 | 984 | CGVEA | CFSUV 1655253184.6499498 | 996 | CGLDP | JZA161 A separation of 31 metres is so small that it\u0026rsquo;s worth double checking the data to see what those two aircraft were doing at exactly 1655317602.2365394.\nSELECT ST_AsText(geom) FROM ( SELECT (ST_DumpPoints(flight.geom)).* FROM flight WHERE callsign = \u0026#39;CGGGO\u0026#39;) AS g; From the points in flight CGGGO, we see that there were ADS-B state vectors recorded two minutes before and 13 seconds after 1655317602, but no state vector exactly at 1655317602.\npath | st_astext ------+----------------------------------------------------------------- {1} | POINT ZM (1218224.1390170476 455564.6965150813 0 1655317419) {2} | POINT ZM (1218370.96000034 455381.88762515073 0 1655317425) {3} | POINT ZM (1218440.9541452834 455284.7816067032 0 1655317428) {4} | POINT ZM (1218456.977321602 455252.1045787118 0 1655317429) {5} | POINT ZM (1218559.022961798 455089.6465681435 0 1655317434) {6} | POINT ZM (1218582.8252591728 455046.18074272043 0 1655317436) {7} | POINT ZM (1218614.8748292197 454980.82785217743 0 1655317437) {8} | POINT ZM (1218623.5907024834 454947.84267283714 0 1655317438) {9} | POINT ZM (1218624.5285217932 454925.6466826303 0 1655317439) {10} | POINT ZM (1218634.1823688783 454870.46557313844 0 1655317440) {11} | POINT ZM (1218635.5891432345 454837.17162861006 0 1655317441) {12} | POINT ZM (1218636.5269924412 454814.975674214 0 1655317442) {13} | POINT ZM (1218632.4999741595 454736.98104434885 0 1655317444) {14} | POINT ZM (1218627.066055597 454692.2803657774 0 1655317445) {15} | POINT ZM (1218598.019306817 454513.16918261163 0 1655317450) {16} | POINT ZM (1218524.7346475082 453820.77799814986 0 1655317466) {17} | POINT ZM (1218516.20432238 453675.88890926924 0 1655317469) {18} | POINT ZM (1218497.63525764 453074.757360585 304 1655317482) {19} | POINT ZM (1218212.1383303064 445414.31268528895 609 1655317615) {20} | POINT ZM (1218196.3919528325 445091.2794655764 609 1655317620) {21} | POINT ZM (1218224.3295626454 442858.135926426 914 1655317663) {22} | POINT ZM (1218221.4493862633 441879.82805676176 914 1655317684) ... What PostGIS is doing is interpolating the coordinates when the exact measure value does not exist in the data set:\nWITH point AS ( SELECT callsign, ST_GeometryN(ST_LocateAlong(ST_Transform(a.geom, 3005), 1655317602.2365394), 1) AS pa FROM flight AS a WHERE a.callsign in (\u0026#39;CGGGO\u0026#39;, \u0026#39;WEN3354\u0026#39;) ) SELECT callsign, ST_AsText(ST_Force3DZ(pa), 0) AS position FROM point; Compare the results with the table above and you\u0026rsquo;ll see how the values fit between the two highlighted lines.\ncallsign | position ----------+------------------------------ CGGGO | POINT Z (1218240 446149 580) WEN3354 | POINT Z (1218249 446149 609) Apply a little Pythagorean theorem and the distance was, in fact, 31 metres. Well \u0026hellip; sort of. Because of gaps in the ADS-B data, all PostGIS can do is estimate where the planes actually were. But if those estimates were correct, then the rest of the math does, in fact, check out!\nThese are also sometimes called Mode-S codes.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nICAO 24 numbers are often found in upper case online, but most OpenSky API endpoints accept them only in lower case.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNote that the latitude/longitude ordering switches between the /states and /tracks endpoints!\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOne disadvantage, however, is that the function is tied to this table.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTraffic Collision Avoidance System.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 January 0001","permalink":"/pages/ads-b/","section":"Pages","summary":"ADS-B data\u003e ADS-B data # Can standard geospatial tools be used with transmissions from Automatic Dependent Surveillance-Broadcast (ADS-B) equipment aboard aircraft? I wanted to find out because unlike most geospatial data, ADS-B has a third dimension and a fourth dimension.","title":"Multidimensional data in PostGIS"},{"content":"","date":"1 January 0001","permalink":"/tags/ottoman/","section":"Tags","summary":"","title":"ottoman"},{"content":"\n","date":"1 January 0001","permalink":"/pages/","section":"Pages","summary":"","title":"Pages"},{"content":"","date":"1 January 0001","permalink":"/tags/postgis/","section":"Tags","summary":"","title":"postgis"},{"content":"","date":"1 January 0001","permalink":"/tags/postgres/","section":"Tags","summary":"","title":"postgres"},{"content":"","date":"1 January 0001","permalink":"/tags/postgresql/","section":"Tags","summary":"","title":"postgresql"},{"content":"","date":"1 January 0001","permalink":"/tags/python/","section":"Tags","summary":"","title":"python"},{"content":"I authored two Python modules that make it easier to use geospatial Python from within your PostgreSQL database.\nplpygis\u003e plpygis # plpygis is a Python conveter to and from the PostGIS geometry type, WKB, EWKB, GeoJSON and Shapely geometries and additionally supports __geo_interface__. plpygis is intended for use in PL/Python functions, making the entire Python geospatial ecosystem available in SQL queries.\nA simple Python function using plpygis would be:\nCREATE OR REPLACE FUNCTION swap(geom geometry) RETURNS geometry AS $$ # swaps the x and y coordinates of a point from plpygis import Geometry, Point old_point = Geometry(geom) new_point = Point([old_point.y, old_point.x]) return new_point $$ LANGUAGE plpython3u; The magic happens with Geometry(geom), which is automatically converts from PostGIS\u0026rsquo;s geometry type, and the return statement, which automatically converts back to a PostGIS geometry.\nThe function above can be called with a normal SQL statement:\nSELECT swap(geom) FROM city; I spoke about plpygis at FOSS4G 2017 in Boston. The slides are here and a video of the talk is also available.\nDocumentation Source code geofdw\u003e geofdw # geofdw is a collection of PostGIS-related foreign data wrappers for PostgreSQL written in Python using the multicorn extension. By using a FDW, you can access spatial data through Postgres tables without having to import the data first, which can be useful for dynamic or non-tabular data available through web services.\nSource code ","date":"1 January 0001","permalink":"/pages/python-postgis/","section":"Pages","summary":"I authored two Python modules that make it easier to use geospatial Python from within your PostgreSQL database.\nplpygis\u003e plpygis # plpygis is a Python conveter to and from the PostGIS geometry type, WKB, EWKB, GeoJSON and Shapely geometries and additionally supports __geo_interface__.","title":"Python for PostGIS"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"1 January 0001","permalink":"/tags/syriac/","section":"Tags","summary":"","title":"syriac"},{"content":"","date":"1 January 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]