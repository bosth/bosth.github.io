[{"content":"","date":"1 April 2023","permalink":"/","section":"Benjamin Trigona-Harany | jaxartes.net","summary":"","title":"Benjamin Trigona-Harany | jaxartes.net"},{"content":"","date":"1 April 2023","permalink":"/tags/geospatial/","section":"Tags","summary":"","title":"geospatial"},{"content":"","date":"1 April 2023","permalink":"/tags/history/","section":"Tags","summary":"","title":"history"},{"content":" A geospatial solution to Ottoman travel times Imagine you were a bureaucrat in the Ottoman government and your posting as assistant governor of the province of Sivas had ended and you were about to take up a position on a commission in the city of Selânik (Thessaloniki).1\nHow would you have made that journey? How long would it have taken?\nAs a graduate student, I had come across raw data on travel times in some Ottoman primary sources, and this raw data can be fed into a routing engine to calculate the optimal journey for our imaginary Ottoman. This is how I found the data and built the engine.\nThe Data # Sâlnâmes # The first sources are the provincial sâlnâmes, annals or almanacs published by the governments of each vilâyet (province) from the mid-1860s onwards. The sâlnâmes contain a wealth of information of interest to a researcher, including administrative, demographic and economic data; in addition, many sâlnâmes also include lists or tables giving travel times between important settlements inside the province or between the province and other important Ottoman cities.\nSâlnâme-i Vilâyet-i Van # As an example, the yearbook for Van from 1315 [1897/1898] has a list of travel times for the provincial capital and district centres.\nDistances from Bargiri and Erciş Bargiri kazâsı [Bargiri district] mesâfesi [distance] sâat [hours] merkez-i vilâyete olan mesâfesi [distance to the provincial centre] 14 Erciş'e olan mesâfesi [distance to Erciş] 6 Erciş kazâsı [Erciş district] merkez-i vilâyete olan mesâfesi [distance to the provincial centre] 18 Bargiri'ye olan mesâfesi [distance to Bargiri] 6 Âdilcevâz'a olan mesâfesi [distance to Âdilcevâz] 12 Sâlnâme-i Vilâyet-i Adana # The Adana yearbook from 1318 [1900/1901] presents similar information but in table format.\nAdana and Cebel-i Bereket sections of travel times table Maps # In aggregate, the provincial sâlnâmes have a tremendous amount of data in them, and it would be possible to reconstruct a graph of travel times for the entire Ottoman Empire. This was briefly my initial approach but I found that this work had already done by contemporary cartographers and that several maps could be leveraged to ease the process.\nOttoman map from 1855/1856 # The oldest map that I have found dates back to 1272 [1855/1856], although the border with the Kingdom of Greece does not appear to match the actual border in 1855 (or any other year). The map is entirely in Ottoman Turkish.\nEvery point-to-point connection has a travel time indicated. Approximate vilâyet borders are shown. There are tables showing travel times from Istanbul, Samsun, Trabzon, Varna, İzmir and Selânik. Maritime connections are not shown. Bosnia and everything north of the Danube are omitted. Most of Iraq and everything south of Damascus are omitted. Connections in Thrace and the Dardanelles Travel times from Varna Ottoman map from 1891/1892 # The second map dates from 1309 [1891/1892] and is also in Ottoman Turkish. It provides significantly more detail than the previous map, including in areas which were never or no longer part of the Ottoman Empire.2\nSea of Marmara and the Istanbul-Ankara railway Most point-to-point connections have travel times. The missing times are typically for regions outside the Ottoman Empire, but there are exceptions. The symbology of settlements differs depending on their administrative function (e.g. the administrative centre of a vilâyet is different from that of a kazâ). Four different types of connections are shown: railroads, chaussées, main roads and roads. Maritime connections are not shown. Travel times between major ports are shown as a table. Map legend and connections in Palestine French map from 1899 # The final map is the work of one R. Huber and is based off of the 1317 [1899] sâlnâme. Unlike the previous two maps, it is not in Ottoman Turkish, but French, and it has less detail.\nMost point-to-point connections have travel times. Rail connections are measured in kilometres. Vilâyet and sancak borders are shown. Population figures and other figures are given for administrative subdivisions. The symbology of settlements differs depending on their administrative function (e.g. the administrative centre of a vilâyet is different from that of a kazâ). Four different types of connections are shown: railroads, projected railroads, chaussées, roads and maritime routes. Connections from the seat of government for the vilâyet of Mamûretü\u0026rsquo;l-Azîz The Engine # As a proof-of-concept, I digitised a significant part of the 1899 map, encoding the settlements as points and the connections between them as lines in a PostgreSQL database with PostGIS support.\nNetwork of edges and nodes in QGIS Network analysis for point-to-point travel is a well-understood problem, and pgRouting implements Dijkstra\u0026rsquo;s algorithm to find the lowest-cost path between two nodes, using the hours listed on the map as the cost of each edge.\nUsing Dijkstra\u0026rsquo;s algorithm and the data from the 1899 map, I calculated the optimal route between Sivas and Selânik would have taken almost five days:\nSivas to Tokat via Kargın (road, 16h) Tokat to Ünye via Gümenek, Niksar, Karakuş (chaussee, 1 day, 5 hours) Ünye to Selânik via Samsun, İstanbul, Gelibolu, Çanakkale (ship, 3 days) An Application # I published a simple web application as \u0026ldquo;Ottoman Route Finder\u0026rdquo; at https://www.jaxartes.net/ottoman-route-finder/ so anyone can calculate that it takes about six days and ten hours to travel from Devebağırtan Kapısı (me neither) to İd.\nRoute plan from Devebağırtan Kapısı in the Balkans to İd near Erzurum In addition to PostgreSQL, PostGIS and pgRouting, the tech stack includes GeoServer to expose the database via a Web Feature Service (WFS) and OpenLayers as a web-mapping library.\nLimitations # The application is only as good as the input data so I am relying on the mapmakers\u0026rsquo; and sâlnâme authors\u0026rsquo; accuracy. Timetables for the railways are not available, so the travel times that you see are very much how long someone would have literally been travelling as opposed to how long it would have taken end-to-end. In some cases, maps show connections but there is no travel time given; in those cases, I estimated the travel time based on the connection type and the typical time needed to travel that distance based on other connections in the map. This assumption may be wrong. I added ferries across the Bosphorus and known tramlines inside Istanbul, but I do not have timetables for these, so durations are estimated. Since the railway connections are measured in kilometres rather than hours, I also estimated those. I did not complete my digitisation of the 1899 map, but it does include the Balkans and most of Anatolia. This is loosely based on the actual case of Cercîs Efendi, a Syriac Christian who held these positions in the late nineteenth and early twentieth centuries. He later lived in Samsun on the Black Sea coast.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nI believe this map came to me from Nick Danforth of http://www.midafternoonmap.com/ fame.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 April 2023","permalink":"/pages/ottoman-travel/","section":"Pages","summary":"A geospatial solution to Ottoman travel times Imagine you were a bureaucrat in the Ottoman government and your posting as assistant governor of the province of Sivas had ended and you were about to take up a position on a commission in the city of Selânik (Thessaloniki).","title":"Navigation in the Ottoman Era"},{"content":"","date":"1 April 2023","permalink":"/tags/ottoman/","section":"Tags","summary":"","title":"ottoman"},{"content":"\n","date":"1 April 2023","permalink":"/pages/","section":"Pages","summary":"","title":"Pages"},{"content":"","date":"1 April 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"1 January 2023","permalink":"/tags/boardgames/","section":"Tags","summary":"","title":"boardgames"},{"content":"","date":"1 January 2023","permalink":"/tags/csp/","section":"Tags","summary":"","title":"csp"},{"content":" Mission planning with the Z3 Theorem Prover Leaving Earth # Leaving Earth is a board game by Joseph Fatula that recreates the space race of the 1950s, 60s and 70s. At the start of the game, a handful of missions will be revealed and the players compete to be the first to complete each one, scoring points based on their complexity. Many of these missions are examples of actual human accomplishments - such as Venus Lander - while others - Mars Station - are more fanciful.\nEasy missions in Leaving Earth In real life, the United States would have just edged the Soviet Union 43 points to 42 Mission Planning # The core mechanic in Leaving Earth is planning the missions using a variety of rockets, capsules and other components to perform a series of maneuvers from one location to another.\nFrom a Lunar orbit, a spacecraft may land on the Moon or fly back to an Earth Orbit The key concept is that each maneuver has a difficulty - roughly approximating Delta-v - and each rocket can produce a certain amount of thrust, at which point it is expended.1 The amount of thrust required to perform a maneuver is based on this simple formula: thrust required = mass × difficulty. The final factor, mass, is determined by the number of components aboard the spacecraft.\nA simple mission plan for a spacecraft travelling from Earth to the Lunar surface might look like the following (the numbers in parentheses indicates the mass of that component):\nManeuver Difficulty Rockets Used Payload Required Thrust Earth to Earth Orbit 8 Saturn (20) Atlas (4), Juno (1), Probe (1) 26 × 8 Earth Orbit to Lunar Orbit 3 Atlas (4) Juno (1), Probe (1) 6 × 3 Lunar Orbit to Moon 2 Juno (1) Probe (1) 2 × 2 As long as the rockets used in each stage of this mission can product the required thrust, then the maneuver can be completed. In the example above, a Saturn rocket produces 200 thrust, an Atlas 27 thrust and a Juno 4, so each maneuver succeeds.\nAn alternative route to space would be to use a two-stage launch to avoid the difficulty 8 maneuver required to go directly from the Earth\u0026rsquo;s surface to Earth Orbit.\nManeuver Difficulty Rockets Used Payload Required Thrust Earth to Suborbital Flight 3 Soyuz (9) Soyuz (9), Atlas (4), Juno (1), Probe (1) 24 × 3 Suborbital Flight to Earth Orbit 5 Soyuz (9) Atlas (4), Juno (1), Probe (1) 15 × 5 Earth Orbit to Lunar Orbit 3 Atlas (4) Juno (1), Probe (1) 6 × 8 Lunar Orbit to Moon 2 Juno (1) Probe (1) 2 × 2 A Soyuz produces only 80 thrust, but using this rocket type in a two-stage configuration means that it can still reach orbit. In fact, two Soyuz rockets can carry a payload of 7 mass into orbit, whereas a single Saturn can only carry 5. And since in the game\u0026rsquo;s economy a Soyuz only costs $8 compared to a hefty $15 for a Saturn, the former starts to look like an attractive proposition. That is until you start planning a mission that requires moving a large amount of mass into orbit, such as transporting humans to Mars and back again.\nThe rockets of Leaving Earth, showing mass, cost and thrust There are many other mission planning complexities: Ion Thrusters, which are not expended but take time to travel from one location to another; slingshot maneuvers to travel to the outer reaches of the solar system; one-way maneuvers; and more. But the basic concept I presented above is enough to move on.\nConstraint Satisfaction Problems # So how can Leaving Earth\u0026rsquo;s mission planning be reduced to a Constraint Satisfaction Problem (CSP)?\nLet\u0026rsquo;s take the difficulty 8 maneuver from Earth to Earth Orbit and rewrite it as a CSP. To simplify things, we\u0026rsquo;ll assume that there are only Saturn and Soyuz rockets available.\nThe question we want to solve is how many Saturn and how many Soyuz rockets are needed to move a mass of, say, 2 from Earth to Earth Orbit. In other words, we want to find the values of two variables, saturn and soyuz, such that they satisfy a set of constraints.\nThe first two constraints are that both variables must be greater or equal to zero (we don\u0026rsquo;t allow negative numbers of rockets):\nsaturn ≥ 0 soyuz ≥ 0 Next, our Leaving Earth formula thrust required = mass × difficulty needs to be rewritten slightly as thrust produced ≥ mass × difficulty; in other words, we need to make sure that the thrust produced by the Saturn and Soyuz rockets that we use is large enough.\nTo write this constraint, first consider what we know:\npayload = 2 thrust produced = saturn × 200 + soyuz × 80 mass = saturn × 20 + soyuz × 9 + payload difficulty = 8 Then bring this information together as a third and final constraint:\nsaturn × 200 + soyuz × 80 ≥ (saturn × 20 + soyuz × 9 + 2) × 8 Let\u0026rsquo;s propose a hypothetical solution to the problem that is saturn = 0, soyuz = 1. To check if this is a solution we need to ensure that the three constraints are satisfied.\nsaturn ≥ 0: 0 is greater or equal to 0 soyuz ≥ 0: 1 is greater or equal to 0 saturn × 200 + soyuz × 80 ≥ (saturn × 20 + soyuz × 9 + 2) × 8: 80 ≥ 88 Unfortunately, we do not satisfy the third constraints, so this is not a valid solution; a single Soyuz rocket is not powerful enough to carry this payload into Earth Orbit. What if we try again with two Soyuz rockets?\nsaturn ≥ 0: 0 is greater or equal to 0 soyuz ≥ 0: 2 is greater or equal to 0 saturn × 200 + soyuz × 80 ≥ (saturn × 20 + soyuz × 9 + 2) × 8: 160 ≥ 160 The final constraint is now satisfied, and this two-engine spacecraft is able to boost a payload of mass 2 into Earth Orbit!\nFinally, if we used a single Saturn rocket, we also have a valid solution:\nsaturn ≥ 0: 1 is greater or equal to 0 soyuz ≥ 0: 0 is greater or equal to 0 saturn × 200 + soyuz × 80 ≥ (saturn × 20 + soyuz × 9 + 2) × 8: 200 ≥ 176 In fact, any combination of two or more Saturn and Soyuz rockets will satisfy this CSP (e.g. saturn = 2, soyuz = 0, saturn = 1, soyuz = 1 and saturn = 5, soyuz = 3 are all valid solutions).\nNow if the payload size increased from 2 to, say, 10, and we allowed all the different rocket types modelled in Leaving Earth, then the set of solutions is perhaps not so obvious.\nZ3 theorem prover # This is where a CSP solver comes in handy. Z3 is a toolkit for solving CSPs with bindings for several languages, including Python, which is the language I\u0026rsquo;ll be using here.\nSolving a single maneuver # Rewriting the CSP above in Z3 for a payload of 10 and a maneuver of difficulty 5 would look like this:\nfrom z3 import solve, Int saturn = Int(\u0026#34;saturn rockets\u0026#34;) soyuz = Int(\u0026#34;soyuz rockets\u0026#34;) payload = 10 thrust = saturn*200 + soyuz*80 mass = saturn*20 + soyuz*9 + payload difficulty = 5 solve(saturn\u0026gt;=0, soyuz\u0026gt;=0, thrust \u0026gt;= mass * difficulty) Z3 will return the following result:\n[saturn rockets = 0, soyuz rockets = 2] In other words, 2 Soyuz rockets can transport a payload of 10 to Suborbital Flight. This certainly is a solution, but is it the optimal solution? For this, we have to decide what defines optimal. Is it the number of rockets? The total mass of the rockets? Or is it the cost of the rockets used? If we are thinking about a game of Leaving Earth, it\u0026rsquo;s probably the cost.\nLet\u0026rsquo;s rewrite the function but with a cost optimization and let\u0026rsquo;s add all the remaining rockets in as variables.\nfrom z3 import Optimize, Int saturn = Int(\u0026#34;saturn rockets\u0026#34;) soyuz = Int(\u0026#34;soyuz rockets\u0026#34;) atlas = Int(\u0026#34;atlas rockets\u0026#34;) juno = Int(\u0026#34;juno rockets\u0026#34;) payload = 10 thrust = saturn*200 + soyuz*80 + atlas*27 + juno*4 mass = saturn*20 + soyuz*9 + atlas*4 + juno*1 + payload difficulty = 5 cost = saturn*15 + soyuz*8 + atlas*5 + juno*1 solver = Optimize() solver.add(saturn \u0026gt;= 0) solver.add(soyuz \u0026gt;= 0) solver.add(atlas \u0026gt;= 0) solver.add(juno \u0026gt;= 0) solver.add(thrust \u0026gt;= mass * difficulty) solver.minimize(cost) solver.check() solver.model() And this returns:\n[saturn rockets = 1, soyuz rockets = 0, atlas rockets = 0, juno rockets = 0] And of course you can get a mix of rockets with the right conditions, such as by setting payload to 21, giving:\n[saturn rockets = 1, soyuz rockets = 0, atlas rockets = 1, juno rockets = 0] Solving longer missions # When it\u0026rsquo;s just a single maneuver, the constraints end up being quite simple; however, missions in Leaving Earth inevitably have multiple steps. Fortunately, this is not difficult to express in Z3. Let\u0026rsquo;s take the mission from Earth Orbit to the Moon. We have a maneuver of difficulty 3, followed by a maneuver of difficulty 2.\ngraph TD A((Earth)) --\u003e|3| B(Suborbital Flight) B --\u003e|5| C(Earth Orbit) A --\u003e|8| C C --\u003e|3| D(Lunar Orbit) D --\u003e|2| E((Moon)) The key here is to express this mission backwards; in other words, we\u0026rsquo;ll make sure we can travel from Lunar Orbit to the Moon first and then ensure we can travel from Earth Orbit to Lunar Orbit.\nAnd crucially, the payload gets larger and larger as we move backwards in the mission by the number of rockets that will be expended in the future (remember that once a rocket is used, it is removed from the spacecraft):\nStage Maneuver Difficulty Payload 0 Lunar Orbit to Moon 2 5 1 Earth Orbit to Lunar Orbit 3 5 + mass of rockets used in Stage 0 In Z3, this would be:\nfrom z3 import Optimize, IntVector, Int solver = Optimize() maneuvers = [3, 2] maneuvers.reverse() # plan the mission backwards payload = 5 saturn = IntVector(\u0026#34;saturn rockets\u0026#34;, len(maneuvers)) soyuz = IntVector(\u0026#34;soyuz rockets\u0026#34;, len(maneuvers)) atlas = IntVector(\u0026#34;atlas rockets\u0026#34;, len(maneuvers)) juno = IntVector(\u0026#34;juno rockets\u0026#34;, len(maneuvers)) cost = 0 # running total of the cost for i, difficulty in enumerate(maneuvers): solver.add(saturn[i] \u0026gt;= 0) solver.add(soyuz[i] \u0026gt;= 0) solver.add(atlas[i] \u0026gt;= 0) solver.add(juno[i] \u0026gt;= 0) thrust = saturn[i]*200 + soyuz[i]*80 + atlas[i]*27 + juno[i]*4 thruster_mass = saturn[i]*20 + soyuz[i]*9 + atlas[i]*4 + juno[i]*1 mass = thruster_mass + payload solver.add(thrust \u0026gt;= mass * difficulty) cost += saturn[i]*15 + soyuz[i]*8 + atlas[i]*5 + juno[i]*1 payload += thruster_mass solver.minimize(cost) solver.check() solver.model() Removing all the unused rockets, we are left with the following:\n[atlas rockets0 = 1, soyuz rockets1 = 1] This is saying that for maneuver 0, we need an Atlas and for maneuver 1, we need a Soyuz. Remember that we planned this backwards, so 0 is the last maneuver (i.e. Lunar Orbit to the Moon) and 1 is the maneuver that came before it (i.e. Earth Obit to Lunar Orbit).\nThe amazing thing is that by simply changing the line maneuvers = [3, 2], we can solve any one-way mission in Leaving Earth that uses expendable rockets.\nEarth to the Moon? maneuvers = [8, 3, 2]\nEarth to the Moon with a two stage launch? maneuvers = [3, 5, 3, 2]\nEarth to Mercury with a two stage launch? maneuvers = [3, 5, 3, 5, 2, 2]\nIon Thrusters # Ion Thrusters work a little differently: they can\u0026rsquo;t be used for maneuvers travelling to or from celestial bodies; they are not expended when they are used; they produce 5 thrust for every year the journey takes. As an example, if a spacecraft composed of a Probe (mass 1) and an Ion Thruster (mass 1) travels from Earth Orbit to Lunar Orbit, then the journey will take 2 years to complete. The same formula - thrust required = mass × difficulty - applies, giving (1+1) × 3 = 6. Ion Thrusters generate 5 thrust per year so one year of travel would only provide 5 thrust and we need 6, hence two years.\nSince Ion Thrusters are not expended, they are very efficient as long as you aren\u0026rsquo;t in a hurry, but remember Leaving Earth is a race to get points!\nLet\u0026rsquo;s add support for Ion Thrusters to the code above. First we need to add the Ion Thrusters\u0026rsquo; mass and cost once but add their thrust at each stage. Second, we need to introduce a new variable for the number of years each maneuver takes.\nfrom z3 import Optimize, IntVector, Int solver = Optimize() maneuvers = [3, 5, 2] maneuvers.reverse() # plan the mission backwards payload = 5 saturn = IntVector(\u0026#34;saturn rockets\u0026#34;, len(maneuvers)) soyuz = IntVector(\u0026#34;soyuz rockets\u0026#34;, len(maneuvers)) atlas = IntVector(\u0026#34;atlas rockets\u0026#34;, len(maneuvers)) juno = IntVector(\u0026#34;juno rockets\u0026#34;, len(maneuvers)) ion = Int(\u0026#34;ion thrusters\u0026#34;) year = IntVector(\u0026#34;years travelled\u0026#34;, len(maneuvers)) solver.add(ion \u0026gt;= 0) cost = 0 # running total of the cost years = 0 # running total of journey time payload += ion * 1 # add the weight of the ion thrusters to the payload once cost += ion * 10 # add the cost of the ion thrusters to the total once for i, difficulty in enumerate(maneuvers): solver.add(saturn[i] \u0026gt;= 0) solver.add(soyuz[i] \u0026gt;= 0) solver.add(atlas[i] \u0026gt;= 0) solver.add(juno[i] \u0026gt;= 0) solver.add(year[i] \u0026gt;= 0) thrust = saturn[i]*200 + soyuz[i]*80 + atlas[i]*27 + juno[i]*4 + ion*year[i]*5 thruster_mass = saturn[i]*20 + soyuz[i]*9 + atlas[i]*4 + juno[i]*1 mass = thruster_mass + payload solver.add(thrust \u0026gt;= mass * difficulty) years += year[i] cost += saturn[i]*15 + soyuz[i]*8 + atlas[i]*5 + juno[i]*1 payload += thruster_mass solver.minimize(cost) solver.check() solver.model() The code above is for a journey from Earth Orbit to Mercury Orbit. Because Ion Thrusters can\u0026rsquo;t be used to reach space from Earth, the code would need to be more complex to support the full journey, but this is good enough for now.\n[ion thrusters = 1, years travelled0 = 3, years travelled1 = 9, years travelled2 = 4] Stage Maneuver Difficulty Time 2 Earth Orbit to Inner Planets Transfer 3 4 1 Inner Planets Transfer to Mercury Fly-by 5 9 0 Mercury Fly-by to Mercury Orbit 2 3 For $10 in game money, a single Ion Thruster will carry a payload all the way to Mercury! The only problem is that it will take 16 years \u0026hellip; but what if we ask Z3 to optimize for the journey time?\nsolver.minimize(cost) solver.minimize(years) Now cost is still the most important factor but years will also be minimized and the new results are that the journey will take 13 years. You can also flip the order of the two minimize statements so that the critical factor is the journey time and cost is only of secondary importance!\n[juno rockets0 = 5, saturn rockets1 = 1, saturn rockets2 = 1] Now suddenly, Z3 wants us to use expendable rockets for each maneuver because they don\u0026rsquo;t have the additional time cost of the Ion Thrusters.2 The monetary cost is significantly higher, however, at $35!\nControlling costs # In order to controlling spiralling program costs, we can add an additional constraint on how much is spent on a mission. Let\u0026rsquo;s say we are budgeting $25 on our mission to Mercury from Earth Orbit. We still want it completed as fast as possible, but it has to fall below this budget.\nsolver.add(cost \u0026lt;= 25) solver.minimize(years) solver.minimize(cost) Z3 finds a nice balance between rockets and Ion Thrusters, with the Ion Thrusters used at every stage but an Atlas also providing an initial boost:\n[ion thrusters = 2, atlas rockets2 = 1, years travelled0 = 2, years travelled1 = 4, years travelled2 = 1] Stage Maneuver Difficulty Time Rockets 2 Earth Orbit to Inner Planets Transfer 3 1 Atlas 1 Inner Planets Transfer to Mercury Fly-by 5 4 0 Mercury Fly-by to Mercury Orbit 2 2 Leaving Earth Solver # I put all of this and more together into a Python package to solve many (but not all) Leaving Earth missions, including rules from Outer Planets and Stations. It\u0026rsquo;s a command-line tool that works like this:\nbosth/leaving-earth-solver Leaving Earth Solver Python 1 2 Usage # Use les --help to get a list of arguments and parameters:\nUsage: les [OPTIONS] ORIGIN DESTINATION [PAYLOAD] Options: --version Show the version and exit. -v, --verbose Verbose mode -j, --juno RANGE Number of Juno rockets -a, --atlas RANGE Number of Atlas rockets -s, --soyuz RANGE Number of Soyuz rockets -p, --proton RANGE Number of Proton rockets -n, --saturn RANGE Number of Saturn rockets -i, --ion RANGE Number of Ion thrusters -c, --cost RANGE Cost of mission -m, --minimize [time|cost|mass] Minimization goal --single-stage Check a single stage configuration for launches from Earth (by default only a two- stage configuration will be attempted) --aerobraking / --no-aerobraking Use aerobraking --rendezvous / --no-rendezvous If rendezvous technology is available, Ion thrusters will be detached when no longer needed -t, --time RANGE Number of time tokens -y, --year INTEGER RANGE Year that journey starts [1956\u0026lt;=x\u0026lt;=1986] --help Show this message and exit. The basic pattern is to provide the origin and destination and les will assume a payload of size 1:\nles Eo L The results are a JSON description of the entire mission:\n{ \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 5 }, \u0026#34;payload\u0026#34;: 1, \u0026#34;mass\u0026#34;: 5, \u0026#34;cost\u0026#34;: 5, \u0026#34;time\u0026#34;: 0, \u0026#34;plan\u0026#34;: [ { \u0026#34;origin\u0026#34;: \u0026#34;Earth orbit\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;Lunar fly-by\u0026#34;, \u0026#34;difficulty\u0026#34;: 1, \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 2 }, \u0026#34;thrust\u0026#34;: 8 }, { \u0026#34;origin\u0026#34;: \u0026#34;Lunar fly-by\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;Lunar orbit\u0026#34;, \u0026#34;difficulty\u0026#34;: 2, \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 2 }, \u0026#34;thrust\u0026#34;: 8 }, { \u0026#34;origin\u0026#34;: \u0026#34;Lunar orbit\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;Moon\u0026#34;, \u0026#34;difficulty\u0026#34;: 2, \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 1 }, \u0026#34;thrust\u0026#34;: 4 } ] } This plan uses Lunar Fly-by because of the low difficulty maneuver from Earth Orbit If you don\u0026rsquo;t have Saturn technology (or don\u0026rsquo;t want Saturn rockets to be part of the solution), you can force them to 0:\nles Eo L --saturn 0 les understands the following format for the numbers provided to it:\nParameter Range 1 exactly 1 1+ 1 or more 1-3 1 to 3 -3 3 or fewer More examples # To find the optimal solution for a trip that taking 5 mass from Earth (E) to the Moon that uses no Saturn rockets, between 1 and 3 Soyuz rockets and where we are able to detach the Ion Thruster before landing on the Moon (this avoids moving unnecessary mass):\nles E L 5 --saturn 0 --soyuz 1-3 --rendezvous To find the optimal solution for a trip taking 10 mass from Earth to Mars (M) in 5 years or less with aerobraking technology available:\nles E M 10 --aerobraking -t -5 To find the optimal solution for the fastest trip carrying 10 mass from Earth Orbit to Jupiter Fly-by (Jfb) that leaves in 1960.\nles Eo Jfb 10 --year 1960 --minimize time Result:\n{ \u0026#34;start\u0026#34;: 1960, \u0026#34;end\u0026#34;: 1963, \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 3, \u0026#34;soyuz\u0026#34;: 1, \u0026#34;ion\u0026#34;: 1, \u0026#34;atlas\u0026#34;: 1 }, \u0026#34;payload\u0026#34;: 10, \u0026#34;mass\u0026#34;: 17, \u0026#34;cost\u0026#34;: 26, \u0026#34;time\u0026#34;: 3, \u0026#34;plan\u0026#34;: [ { \u0026#34;origin\u0026#34;: \u0026#34;Earth orbit\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;Inner planets transfer\u0026#34;, \u0026#34;difficulty\u0026#34;: 3, \u0026#34;components\u0026#34;: { \u0026#34;soyuz\u0026#34;: 1, \u0026#34;ion\u0026#34;: 1 }, \u0026#34;aerobraking\u0026#34;: false, \u0026#34;year\u0026#34;: 1960, \u0026#34;time\u0026#34;: 1, \u0026#34;thrust\u0026#34;: 85, \u0026#34;slingshot\u0026#34;: false }, { \u0026#34;origin\u0026#34;: \u0026#34;Inner planets transfer\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;Venus fly-by\u0026#34;, \u0026#34;difficulty\u0026#34;: 2, \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 1, \u0026#34;atlas\u0026#34;: 1, \u0026#34;ion\u0026#34;: 1 }, \u0026#34;aerobraking\u0026#34;: false, \u0026#34;time\u0026#34;: 1, \u0026#34;year\u0026#34;: 1961, \u0026#34;thrust\u0026#34;: 36, \u0026#34;slingshot\u0026#34;: false }, { \u0026#34;origin\u0026#34;: \u0026#34;Venus fly-by\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;Jupiter fly-by\u0026#34;, \u0026#34;difficulty\u0026#34;: 1, \u0026#34;components\u0026#34;: { \u0026#34;juno\u0026#34;: 2, \u0026#34;ion\u0026#34;: 1 }, \u0026#34;aerobraking\u0026#34;: false, \u0026#34;year\u0026#34;: 1962, \u0026#34;time\u0026#34;: 1, \u0026#34;thrust\u0026#34;: 13, \u0026#34;slingshot\u0026#34;: true } ] } Leaving Earth in 1960, a spacecraft can use the 1962 slingshot maneuver from Venus to Jupiter How it works # The core concept is identical to what I described above but les also finds the optimal paths from the origin to the destination. In most cases there are multiple paths between two points and the optimal path depends on a number of external factors. Even travelling to the Moon from Earth presents many options:\ngraph TD E((Earth)) --\u003e|3| ESo(Suborbital Flight) ESo --\u003e|5| Eo(Earth Orbit) E --\u003e|8| Eo Eo --\u003e|3| Lo(Lunar Orbit) Lo --\u003e|2| L((fa:fa-ban Moon)) Eo --\u003e|1| Lfb(Lunar Fly-by) Lfb --\u003e|2| Lo Lfb --\u003e|4| L By default, les will try to predict a few plausible paths and solve for each of those, selecting the best solution at the end.\nles is aware of which maneuvers support Ion Thrusters and can detatch these opportunistically when they will no longer be needed to complete a mission. Conversely, it will carry unused Ion Thrusters from one location to the next if they will be used at a future stage.\nIt also can make use of aerobraking, slingshot maneuvers and Proton rockets from the expansions. It doesn\u0026rsquo;t support the reusable shuttles, however, and it won\u0026rsquo;t increase or decrease the difficulty of maneuvers to change travel times. The biggest missing feature, however, is probably not being able to plan return missions (e.g. going to the Moon and back again).\nWhen a rocket is expended, its card is discarded and it is no longer part of the spacecraft.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLeaving Earth players will note that some maneuvers take a minimum amount of time even with rockets, but I am ignoring that for the moment.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 January 2023","permalink":"/pages/leaving-earth/","section":"Pages","summary":"Mission planning with the Z3 Theorem Prover Leaving Earth # Leaving Earth is a board game by Joseph Fatula that recreates the space race of the 1950s, 60s and 70s.","title":"Leaving Earth is a Constraint Satisfaction Problem"},{"content":"","date":"1 January 2023","permalink":"/tags/python/","section":"Tags","summary":"","title":"python"},{"content":"","date":"1 January 2023","permalink":"/tags/z3/","section":"Tags","summary":"","title":"z3"},{"content":"","date":"1 July 2022","permalink":"/tags/ads-b/","section":"Tags","summary":"","title":"ads-b"},{"content":" ADS-B data # Can standard geospatial tools be used with transmissions from Automatic Dependent Surveillance-Broadcast (ADS-B) equipment aboard aircraft? I wanted to find out because unlike most geospatial data, ADS-B has a third dimension and a fourth dimension.\nMy geospatial analysis tool of choice is PostGIS, which has multidimensional geometry types and functions, but I had never really had cause to use them despite having coded support for additional dimensions when I developed plpygis.\nThis article describes the process of getting free ADS-B data, loading it into PostgreSQL and then manipulating it with PostGIS and Python.\nTools # In addition to PostgreSQL and PostGIS, I used two Python modules: requests and plpygis. These must be installed in a location from which PostgreSQL’s PL/Python can import them. I also used QGIS for visualization.\nAircraft identities # Step one was learning about ICAO 24 addresses, unique aircraft identifiers which are included in every ADS-B transmission.1 These are 24-bit values represented by a six-digit hexadecimal number, such as A4DA1. These codes are distinct from the registration numbers that are visible on an aircraft\u0026rsquo;s body or tail.\nUzbekistan Airways IL-76 with registration UK-76428 A single physical aircraft may have multiple ICAO 24 addresses over its lifetime but these change much less frequently than registration numbers.\nDrukair ATR-42 with the registration number A5-RGH (via www.planespotters.net) The ATR-42 in the image above has moved between three airlines and therefore been registered under three different numbers … but also with two different ICAO 24 codes, 3a2270 and 39ad00. The history of these alterations can be found in some databases, such as the one maintained by Planespotters.net.\nThe OpenSky Network # The The OpenSky Network provides free access to ADB-S data via a RESTful API. There is a Python client, but I did not use it since it doesn’t implement everything that is available directly through the API.2\nAnyone may create an OpenSky account as long as they follow the site\u0026rsquo;s terms of use.\nState vectors # Equipped with an ICAO 24 number, I retrieved some actual flight data provided by OpenSky.3 A basic query also requires a specific time, with that time being represented as the number of seconds elapsed since the 1st of January 1970 (otherwise known as UNIX time). For example, the position of the ATR-42 above at 16:01:23 on the 11th of April, 2022 is requested by https://opensky-network.org/api/states/all?icao24=39ad00\u0026time=1649692883.\nThe JSON-encoded response looks like the following:\n{ \u0026#34;time\u0026#34;: 1649692883, \u0026#34;states\u0026#34;: [ [ \u0026#34;39ad00\u0026#34;, \u0026#34;AFR57AG \u0026#34;, \u0026#34;France\u0026#34;, 1649692879, 1649692882, 2.5172, 44.9426, 2263.14, false, 100.86, 24.08, 10.08, null, 2316.48, null, false, 0 ] ] } The data transmitted by the aircraft is stored in the list of states and can be decoded through the OpenSky documentation. From this you know that the aircraft was operating as Air France 57AG, that it recorded a barometric altitude of 2263.14 meters, that it had a ground speed of 100.86 meters/second and so on.\nTracks # OpenSky simplifies getting a series of state vectors by providing a tracks API endpoint, and although the documentation states that this endpoint is experimental, I’ve had success in using it: https://opensky-network.org/api/tracks/?icao24=39ad00\u0026time=1649692883.\nThe response to the request above will contain some basic facts about the flight, including the first and last times at which it was observed:\n{ \u0026#34;icao24\u0026#34;: \u0026#34;39ad00\u0026#34;, \u0026#34;callsign\u0026#34;: \u0026#34;AFR57AG \u0026#34;, \u0026#34;startTime\u0026#34;: 1649692883, \u0026#34;endTime\u0026#34;: 1649696435, \u0026#34;path\u0026#34;: [...] } The path element is a list of abbreviated state vectors showing the route the aircraft took on this flight. One of these vectors might look like the following:\n[ 1649693075, 45.129, 2.631, 3352, 23, false ] These values are the time, latitude, longitude, barometric altitude, heading and whether the aircraft is on the ground respectively. Note that the latitude/longitude ordering switches between the /states and /tracks endpoints! One other thing to be aware of is that tracks in OpenSky are reported in 1000 foot steps, so aircraft will appear to take off from an altitude of 0m and proceed to an elevation of 304m, then 609m and so on.4 See the Appendix for a function to do this.\nThe one significant limitation with OpenSky is that these flight tracks are only available for flights from the last 30 days.\nFlights # The next endpoint that we’ll be using is /flights/aircraft, which lists all the flights taken by an aircraft: https://opensky-network.org/api/flights/aircraft/?icao24=39ad00\u0026begin=1609455600\u0026end=1609714800.\nOne flight in the list looks like the following:\n{ \u0026#34;icao24\u0026#34;: \u0026#34;39ad00\u0026#34;, \u0026#34;firstSeen\u0026#34;: 1649692883, \u0026#34;estDepartureAirport\u0026#34;: \u0026#34;LFLW\u0026#34;, \u0026#34;lastSeen\u0026#34;: 1649696438, \u0026#34;estArrivalAirport\u0026#34;: \u0026#34;LFPO\u0026#34;, \u0026#34;callsign\u0026#34;: \u0026#34;AFR57AG \u0026#34;, \u0026#34;estDepartureAirportHorizDistance\u0026#34;: 9750, \u0026#34;estDepartureAirportVertDistance\u0026#34;: 1654, \u0026#34;estArrivalAirportHorizDistance\u0026#34;: 3750, \u0026#34;estArrivalAirportVertDistance\u0026#34;: 33, \u0026#34;departureAirportCandidatesCount\u0026#34;: 0, \u0026#34;arrivalAirportCandidatesCount\u0026#34;: 9 } The departure and arrival airports are estimates since these are not explicitly reported by the ADB-S data, so OpenSky infers them from what it observes; on occasion you will see an airport listed as null when there wasn’t enough data to establish what the plane’s origin or destination were.\nAny time between firstSeen and lastSeen can be used with the /tracks endpoint above to get the entire path that the plane took on this flight.\nAirport activity # Two final endpoints that are interesting are /flights/arrival and /flights/departure, which will list all the flights that terminate or originate at a particular airport between two points in time.\nADS-B data in PostGIS # Database creation # Once PostgreSQL and PostGIS are installed and your user has the right privileges, you can run the following on the command line:\ncreatedb opensky Then open the database to interact with it:\npgsql opensky You first need to enable PostGIS:\nCREATE EXTENSION postgis; Create the table to store the flight data:\nCREATE TABLE flight ( icao24 TEXT, callsign TEXT, airport_depart TEXT, airport_arrive TEXT, time_depart TIMESTAMP, time_arrive TIMESTAMP, geom GEOMETRY(LINESTRINGZM, 4326) ); The geometry type LINESTRINGZM means that each vertex in the path will have four dimensions: x and y (longitude and latitude), z (altitude) and m (the “measure” value, which will be used for time).\nFinally, add an index but make it n-dimensional, which optimizes queries across all four dimensions.\nCREATE INDEX ON flight USING gist (geom gist_geometry_ops_nd); PL/Python # There are a few ways to bring the data from the OpenSky API into the database, but I used PL/Python, which means we’ll write a function in Python that will be run from inside the database. To make it easier to work with PostGIS, I also used plpygis, a small Python module that I created to help write PL/Python functions for geospatial data.\nStart by enabling PL/Python:\nCREATE LANGUAGE plpython3u; Let’s start with a simple function that gets a list of flights an aircraft took between two dates. I provided my OpenSky credentials in the environment variables OPENSKY_USER and OPENSKY_PASS, but they could also be set directly in the script.5\nCREATE OR REPLACE FUNCTION opensky_get_aircraft_flights(icao24 TEXT, in_datebegin DATE, in_dateend DATE) RETURNS TABLE (LIKE flight) AS $$ import os OSUSER = os.getenv(\u0026#34;OPENSKY_USER\u0026#34;) OSPASS = os.getenv(\u0026#34;OPENSKY_PASS\u0026#34;) OSURL = \u0026#34;https://opensky-network.org/api\u0026#34; from datetime import datetime from dateutil import parser from requests import Session from requests.auth import HTTPBasicAuth db = parser.parse(in_datebegin) de = parser.parse(in_dateend).replace(hour=23, minute=59) db = int(db.timestamp()) de = int(de.timestamp()) opensky = Session() opensky.auth = HTTPBasicAuth(OSUSER, OSPASS) res = opensky.get( OSURL + \u0026#34;/flights/aircraft/\u0026#34;, params={\u0026#34;icao24\u0026#34; : icao24, \u0026#34;begin\u0026#34; : db, \u0026#34;end\u0026#34; : de}) if res.status_code == 200 and res.text: plpy.info(res.request.url) flights = [(icao24, f[\u0026#34;callsign\u0026#34;].strip() if f[\u0026#34;callsign\u0026#34;] else \u0026#34;\u0026#34;, f[\u0026#34;estDepartureAirport\u0026#34;], f[\u0026#34;estArrivalAirport\u0026#34;], datetime.fromtimestamp(f[\u0026#34;firstSeen\u0026#34;]), datetime.fromtimestamp(f[\u0026#34;lastSeen\u0026#34;]), None) for f in res.json()] return flights else: plpy.info(res.request.url, res.status_code, res.text) return [] $$ LANGUAGE plpython3u; The function definition opensky_get_aircraft_flights takes three arguments, the ICAO 24 code discussed above plus a start and an end date. Returning TABLE (LIKE flight) is a rather useful way that PostgreSQL lets you force the output of a function to match exactly the definition of a table.6\nThe function makes a call to the OpenSky API to get all the flights for the aircraft between the two dates, and returns the results. It does not fill in the track for each flight, but we can write another function to do that:\nCREATE OR REPLACE FUNCTION opensky_get_track(icao24 TEXT, in_date TIMESTAMP WITH TIME ZONE) RETURNS GEOMETRY(LINESTRINGZM, 4326) AS $$ import os OSUSER = os.getenv(\u0026#34;OPENSKY_USER\u0026#34;) OSPASS = os.getenv(\u0026#34;OPENSKY_PASS\u0026#34;) OSURL = \u0026#34;https://opensky-network.org/api\u0026#34; from datetime import datetime from dateutil import parser from requests import Session from requests.auth import HTTPBasicAuth from plpygis import LineString dt = parser.parse(in_date) dt = int(dt.timestamp()) opensky = Session() opensky.auth = HTTPBasicAuth(OSUSER, OSPASS) res = opensky.get( OSURL + \u0026#34;/tracks/\u0026#34;, params={\u0026#34;icao24\u0026#34; : icao24.lower(), \u0026#34;time\u0026#34; : dt}) if res.status_code == 200 and res.text: plpy.info(res.request.url) fl = res.json() return LineString( [[v[2], v[1], v[3], v[0]] for v in fl[\u0026#34;path\u0026#34;]]) else: plpy.info(res.request.url, res.status_code, res.text) return None $$ LANGUAGE plpython3u; Now you can use SQL on the results of this function as if it were a normal database table. For example if you want to know all the unique flight numbers flown by 39ad00 in the first week of May, you can query the OpenSky API like this:\nSELECT DISTINCT callsign FROM opensky_get_aircraft_flights(\u0026#39;c05f01\u0026#39;, \u0026#39;2022-05-01\u0026#39;, \u0026#39;2022-05-07\u0026#39;); callsign ---------- JZA653 JZA652 JZA270 JZA283 JZA651 JZA161 JZA399 JZA300 JZA157 JZA460 JZA801 JZA349 JZA279 JZA322 JZA658 JZA164 JZA282 JZA153 JZA156 JZA295 JZA147 JZA400 JZA810 JZA800 JZA654 JZA803 JZA160 JZA459 One issue that you will observe doing the above is that you are pulling data from the API with every query. It will be much better to have a local copy of the data to work with:\nINSERT INTO flight SELECT * FROM opensky_get_aircraft_flights(\u0026#39;c05f01\u0026#39;, \u0026#39;2022-05-01\u0026#39;, \u0026#39;2022-05-07\u0026#39;); Now the same queries can be run locally from our flight table:\nSELECT DISTINCT callsign FROM flight; And how do we add the tracks?\nUPDATE flight SET geom = opensky_get_track(icao24, time_depart) WHERE date(time_depart) = \u0026#39;2022-05-01\u0026#39;; Remove the WHERE clause and you’ll add tracks to all the flights in your table (which could take a very long time depending on what you have put in there). To add geometries to all the flights without them, you can change the where clause to WHERE geom IS NULL.\nAnd, of course, you can hook the table up to QGIS to see those flight paths.\nFlight tracks rendered in QGIS Geospatial queries # With the data in PostGIS, let’s do some analysis.\nLet’s start easy and say that you want to know how many kilometers 39ad00 flew on the 1st of May:\nSELECT count(*) AS flights, SUM(ST_Length(geom::geography)) / 1000 AS distance FROM flight WHERE date(time_depart) = \u0026#39;2022-05-01\u0026#39;; flights | distance ---------+------------------- 5 | 1499.689291267288 A little more advanced is seeing how often 39ad00 flew between two Canadian airports but travelled over the landmass of the United States to get there. To do this, I downloaded the administrative boundaries data set from NaturalEarth and after unzipping it, I loaded it into the opensky database:\nshp2pgsql -s 4326 -g geom ne_10m_admin_0_countries.shp country | psql opensky And the I ran the following query to find instances when the start and end of a flight were in Canada but at some point the flight path intersected with US territory:\nSELECT f.callsign, f.time_depart, f.airport_depart, f.airport_arrive FROM flight AS f, country AS usa, country AS canada WHERE usa.name = \u0026#39;United States of America\u0026#39; AND canada.name = \u0026#39;Canada\u0026#39; AND ST_Intersects(canada.geom, ST_StartPoint(f.geom)) AND ST_Intersects(canada.geom, ST_EndPoint(f.geom)) AND ST_Intersects(usa.geom, f.geom); callsign | time_depart | airport_depart | airport_arrive ----------+---------------------+----------------+---------- JZA474 | 2022-05-13 01:10:16 | CYCD | CYYC Showing that particular flight in QGIS, we can see how it did, in fact, pass over the United States during its flight.\nJazz Air flight 474 crossed Washington state on its departure from Nanaimo Going multidimensional # Crossed Paths # With some data in our flight table, we can do multidimensional analysis using three dimensions as described in the PostGIS documentation.\nLet\u0026rsquo;s start by seeing if any of the flights had an exact intersections of their flight paths.\nSELECT a.callsign, a.time_depart, b.callsign, b.time_depart, ST_AsText(ST_Intersection(a.geom, b.geom)) FROM flight AS a, flight AS b WHERE a.time_depart \u0026gt; b.dep_time AND ST_Intersects(ST_Force3D(a.geom), ST_Force3D(b.geom)); Note that we are forcing the geometries to be three-dimensional and not four-dimensional. A two-dimentional intersection would ignore altitude completely, while a four-dimensional intersection would be asking for two planes that crossed paths at the exact same point at the exact same time, otherwise known as a mid-air collision.\nAmong the results is something like this, where we can see the exact three-dimensional point at which the paths of Jazz Air flights 168 and 150 intersected one another.\nJZA168 | 2022-06-07 04:49:17 | JZA150 | 2022-06-06 18:15:24 | POINT Z (-123.28160909937012 48.72753520085094 609) The intersection point is expressed in three-dimensional WKT, POINT Z (-123.28160909937012 48.72753520085094 609), where the 609 indicates that the planes were at an altitude of 609 metres or about 2000 feet, a reasonable altitude for planes on approach to an airport.\nFlight tracks for JZA168 and JZA150 crossing paths Click here to see the 3d model above (vertical scale has been exaggerated).\nFour dimensions # Closest points of approach # A four-dimensional intersection is a mid-air collision, and Canada\u0026rsquo;s Civil Aviation Daily Occurrence Reporting System has a queryable database of \u0026ldquo;occurrences\u0026rdquo; on the Transport Canada website. By filtering on the string \u0026ldquo;TCAS\u0026rdquo;7, I found the following incident:\nUPDATE: TSB Report #A22O0076: C-FAXD, a Boeing 737 MAX 8 aircraft operated by Sunwing Airlines Inc, was conducting flight SWG443 from Punta Cana International Airport (PUJ/MDPC), Dominican Republic, to Toronto Pearson International Airport (CYYZ), ON. While on final approach into CYYZ for Runway 33L, the flight crew received a Traffic Alert and Collision Avoidance System (TCAS) resolution advisory (RA) with C-GJVT, an Airbus 320-200 aircraft operated by Air Canada conducting flight ACA264 from Winnipeg/James Armstrong Richardson International Airport (CYWG), MB, to CYYZ, which was on final approach for Runway 33R. SWG443 followed the TCAS RA and aborted the approach to the left. Both aircraft came to a minimum lateral separation of 0.6 Nautical Miles and a minimum vertical separation of 500 feet. SWG443 was at an altitude of 3500 feet and ACA264 at 3000 feet, abeam to each other, on approach for Runways 33L and 33R. SWG443 and ACA264 landed without further incident.\nI wanted to see if I could replicate this narrative in ADS-B data. The first problem is that all the data in the flight table comes from the same airplane, so I added a new function that ingests all the tracks arriving or departing from a specific airport.\nCREATE OR REPLACE FUNCTION opensky_get_airport_flights(airport TEXT, in_datebegin DATE, in_dateend DATE) RETURNS TABLE (LIKE flight) AS $$ import os OSUSER = os.getenv(\u0026#34;OPENSKY_USER\u0026#34;) OSPASS = os.getenv(\u0026#34;OPENSKY_PASS\u0026#34;) OSURL = \u0026#34;Thttps://opensky-network.org/api\u0026#34; from datetime import datetime from dateutil import parser from requests import Session from requests.auth import HTTPBasicAuth db = parser.parse(in_datebegin) de = parser.parse(in_dateend).replace(hour=23, minute=59) db = int(db.timestamp()) de = int(de.timestamp()) opensky = Session() opensky.auth = HTTPBasicAuth(OSUSER, OSPASS) for endpoint in [\u0026#34;arrival\u0026#34;, \u0026#34;departure\u0026#34;]: res = opensky.get( OSURL + \u0026#34;/flights/{}/\u0026#34;.format(endpoint), params={\u0026#34;airport\u0026#34; : airport, \u0026#34;begin\u0026#34; : db, \u0026#34;end\u0026#34; : de}) if res.status_code == 200 and res.text: plpy.info(res.request.url) for f in res.json(): if not f[\u0026#34;firstSeen\u0026#34;] or not f[\u0026#34;lastSeen\u0026#34;]: continue yield (f[\u0026#34;icao24\u0026#34;], f[\u0026#34;callsign\u0026#34;].strip() if f[\u0026#34;callsign\u0026#34;] else \u0026#34;\u0026#34;, f[\u0026#34;estDepartureAirport\u0026#34;], f[\u0026#34;estArrivalAirport\u0026#34;], datetime.fromtimestamp(f[\u0026#34;firstSeen\u0026#34;]), datetime.fromtimestamp(f[\u0026#34;lastSeen\u0026#34;]), None) else: plpy.info(res.request.url, res.status_code, res.text) $$ LANGUAGE plpython3u; I populated it with the flights to and from CYYZ on the date of the incident.\nCREATE TABLE tcas (LIKE flight); INSERT INTO tcas SELECT * FROM opensky_get_airport_flights(\u0026#39;CYYZ\u0026#39;, \u0026#39;2022-06-18\u0026#39;, \u0026#39;2022-06-18\u0026#39;); I could have ingested all the tracks for every row in the table, but since I already knew the affected flights, I just focused on those.\nUPDATE tcas SET geom = opensky_get_track(icao24, time_depart) WHERE callsign IN (\u0026#39;ACA264\u0026#39;, \u0026#39;SWG443\u0026#39;); After adding the tracks, the PostGIS function ST_ClosestPointOfApproach can tell us where along the timelines of two flights are they at their closest proximity. We will, however, want to have the geometry reprojected into a spatial reference system that makes distance calculations using metres - not latitude and longitude - since that is what the altitude is measured in. Since the data set is clustered around Toronto, EPSG:7991 is a good choice.\nST_ClosestPointOfApproach finds the measure value at which two tracks are closest to one another. ST_DistanceCPAprovides the actual three-dimensional distance between the two tracks at this closest point of approach.\nWITH flights AS ( SELECT a.callsign AS fa, b.callsign AS fb, ST_Transform(a.geom, 7991) AS ga, ST_Transform(b.geom, 7991) AS gb FROM tcas AS a, tcas AS b WHERE a.callsign = \u0026#39;ACA264\u0026#39; AND b.callsign = \u0026#39;SWG443\u0026#39; ), cpa AS ( SELECT fa, fb, ga, gb, ST_ClosestPointOfApproach(ga, gb) AS m FROM flights ), points AS ( SELECT fa, fb, ST_Force3DZ(ST_GeometryN(ST_LocateAlong(ga, m), 1)) AS pa, ST_Force3DZ(ST_GeometryN(ST_LocateAlong(gb, m), 1)) AS pb, ST_DistanceCPA(ga, gb) AS distance, m FROM cpa ) SELECT to_timestamp(m) AT TIME ZONE \u0026#39;UTC\u0026#39; AS time, round(distance) AS separation, round(ST_Distance(ST_Force2D(pa), ST_Force2D(pb))) AS lateral_separation, round(abs(ST_Z(pa) - ST_Z(pb))) AS vertical_separation, fa AS a, fb AS b, ST_AsText(ST_Transform(pa, 4326), 3) AS a_position, ST_AsText(ST_Transform(pb, 4326), 3) AS b_position FROM points; According to Transport Canada, the lateral separation at 22:39 UTC should be 0.6 nautical miles, which is is 1111 metres, and the vertical separation should be approximately 500 feet. The ADS-B data doesn\u0026rsquo;t exactly replicate those findings but it\u0026rsquo;s not hugely far off.\ntime | separation | lateral_separation | vertical_separation | a | b | a_position | b_position ---------------------+------------+--------------------+---------------------+--------+--------+----------------------------------+------------------------------ 2022-06-18 22:38:07 | 1119 | 1075 | 310 | ACA264 | SWG443 | POINT Z (-79.448 43.542 604.234) | POINT Z (-79.457 43.536 914) The altitude of the two flights does not match the altitudes stated by Transport Canada; however, the altitude measurement in the tracks is the elevation above ground, so adding ~170m to account for the airport\u0026rsquo;s elevation does bring us into that range.\nFlight tracks for ACA264 and SWG443 and their positions when at their closest Searching for near misses # Lastly, I wanted to see if there were any \u0026ldquo;close calls\u0026rdquo; like the one above that were not reported in the Transport Canada database.\nLet\u0026rsquo;s load the in-bound and out-bound flights at Victoria International Airport (YYJ) on a single day:\nINSERT INTO flight SELECT * FROM opensky_get_airport_flights(\u0026#39;CYYJ\u0026#39;, \u0026#39;2022-06-15\u0026#39;, \u0026#39;2022-06-15\u0026#39;); From this we will see for all flights that have any temporal overlap, there is a single time at which the two flights were closest to one another.\nSELECT to_timestamp(ST_ClosestPointOfApproach(ST_Transform(a.geom, 3005), ST_Transform(b.geom, 3005))) AS time, a.callsign AS flight_a, b.callsign AS flight_b FROM flight as a, flight as b WHERE a.time_depart \u0026gt; b.dep_time AND ST_ClosestPointOfApproach(a.geom, b.geom) IS NOT NULL; An abbreviated output would look like the following:\ntime | flight_a | flight_b -------------------------------+----------+---------- 2022-06-15 16:50:34.289124+02 | WSW209 | ROU1901 2022-06-15 16:13:25+02 | WSW209 | MAL8072 2022-06-15 16:13:25+02 | WSW209 | WJA209 2022-06-15 23:20:26+02 | ASP654 | WJA196 2022-06-15 23:16:29.999995+02 | ASP654 | FLE515 2022-06-15 23:01:11+02 | ASP654 | CGFHA 2022-06-15 23:11:15+02 | ASP654 | CL604KGN 2022-06-15 23:01:03+02 | ASP654 | CGBMO 2022-06-15 23:11:15+02 | ASP654 | ROU1902 2022-06-15 23:01:03+02 | ASP654 | CGBMO Let\u0026rsquo;s say we want to find instances where two aircraft were within 1000 metres of one another:\nWITH flights AS ( SELECT a.callsign AS fa, b.callsign AS fb, ST_Transform(a.geom, 3005) AS ga, ST_Transform(b.geom, 3005) AS gb FROM flight AS a, flight AS b WHERE a.time_depart \u0026gt; b.dep_time ), cpa AS ( SELECT fa, fb, ga, gb, ST_DistanceCPA(ga,gb) AS sd, ST_ClosestPointOfApproach(ga, gb) AS m FROM flights WHERE ST_ClosestPointOfApproach(ga, gb) IS NOT NULL ) SELECT m AS unix_time, round(sd) AS separation, fa AS flight_a, fb AS flight_b FROM cpa WHERE sd \u0026lt;= 1000; This gives us the following output, including one remarkable outlier where two planes were within just 31 metres of one another (at least as reported by the ADS-B data)!\nunix_time | separation | flight_a | flight_b --------------------+------------+----------+---------- 1655318221 | 782 | N90422 | N50KA 1655317602.2365394 | 31 | CGGGO | WEN3354 1655246393.916999 | 984 | CGVEA | CFSUV 1655253184.6499498 | 996 | CGLDP | JZA161 A separation of 31 metres is so small that it\u0026rsquo;s worth double checking the data to see what those two aircraft were doing at exactly 1655317602.2365394.\nSELECT ST_AsText(geom) FROM ( SELECT (ST_DumpPoints(flight.geom)).* FROM flight WHERE callsign = \u0026#39;CGGGO\u0026#39;) AS g; From the points in flight CGGGO, we see that there were ADS-B state vectors recorded two minutes before and 13 seconds after 1655317602, but no state vector exactly at 1655317602.\npath | st_astext ------+----------------------------------------------------------------- {1} | POINT ZM (1218224.1390170476 455564.6965150813 0 1655317419) {2} | POINT ZM (1218370.96000034 455381.88762515073 0 1655317425) {3} | POINT ZM (1218440.9541452834 455284.7816067032 0 1655317428) {4} | POINT ZM (1218456.977321602 455252.1045787118 0 1655317429) {5} | POINT ZM (1218559.022961798 455089.6465681435 0 1655317434) {6} | POINT ZM (1218582.8252591728 455046.18074272043 0 1655317436) {7} | POINT ZM (1218614.8748292197 454980.82785217743 0 1655317437) {8} | POINT ZM (1218623.5907024834 454947.84267283714 0 1655317438) {9} | POINT ZM (1218624.5285217932 454925.6466826303 0 1655317439) {10} | POINT ZM (1218634.1823688783 454870.46557313844 0 1655317440) {11} | POINT ZM (1218635.5891432345 454837.17162861006 0 1655317441) {12} | POINT ZM (1218636.5269924412 454814.975674214 0 1655317442) {13} | POINT ZM (1218632.4999741595 454736.98104434885 0 1655317444) {14} | POINT ZM (1218627.066055597 454692.2803657774 0 1655317445) {15} | POINT ZM (1218598.019306817 454513.16918261163 0 1655317450) {16} | POINT ZM (1218524.7346475082 453820.77799814986 0 1655317466) {17} | POINT ZM (1218516.20432238 453675.88890926924 0 1655317469) {18} | POINT ZM (1218497.63525764 453074.757360585 304 1655317482) {19} | POINT ZM (1218212.1383303064 445414.31268528895 609 1655317615) {20} | POINT ZM (1218196.3919528325 445091.2794655764 609 1655317620) {21} | POINT ZM (1218224.3295626454 442858.135926426 914 1655317663) {22} | POINT ZM (1218221.4493862633 441879.82805676176 914 1655317684) ... What PostGIS is doing is interpolating the coordinates when the exact measure value does not exist in the data set:\nWITH point AS ( SELECT callsign, ST_GeometryN(ST_LocateAlong(ST_Transform(a.geom, 3005), 1655317602.2365394), 1) AS pa FROM flight AS a WHERE a.callsign in (\u0026#39;CGGGO\u0026#39;, \u0026#39;WEN3354\u0026#39;) ) SELECT callsign, ST_AsText(ST_Force3DZ(pa), 0) AS position FROM point; Compare the results with the table above and you\u0026rsquo;ll see how the values fit between the two highlighted lines.\ncallsign | position ----------+------------------------------ CGGGO | POINT Z (1218240 446149 580) WEN3354 | POINT Z (1218249 446149 609) Apply a little Pythagorean theorem and the distance was, in fact, 31 metres. Well \u0026hellip; sort of. Because of gaps in the ADS-B data, all PostGIS can do is estimate where the planes actually were. But if those estimates were correct, then the rest of the math does, in fact, check out!\nAppendix # Interpolating elevations # I mentioned above that the tracks only provide elevations in 1000 foot (approximately 304m) increments. If you plot the raw data returned by the OpenSky API, it will have a \u0026ldquo;stepped\u0026rdquo; appearance; a simple linear interpolation, however, can smooth out the data.\nThe following PL/Python function will group sequential elevations and interpolate their values.\nCREATE OR REPLACE FUNCTION interpolate_track_evelation(geom_in GEOMETRY(LINESTRINGZM)) RETURNS GEOMETRY(LINESTRINGZM) AS $$ from plpygis import Geometry, LineString from itertools import groupby geom = Geometry(geom_in) elevations = [] for _, group in groupby(geom.vertices, lambda x: x.z): elevations.append(list(group)) vertices = [] for i, _ in enumerate(elevations): if i == len(elevations) - 1: for v in elevations[i]: vertices.append([v.x, v.z, v.y, v.m]) else: elev_st = elevations[i][0].z elev_ed = elevations[i+1][0].z time_st = elevations[i][0].m time_ed = elevations[i+1][0].m # catch error of repeating m values if time_ed == time_st: incr = 0 else: incr = (elev_ed - elev_st) / (time_ed - time_st) for v in elevations[i]: x = v.x y = v.y z = v.z + ((v.m - time_st) * incr) m = v.m pt = [x, y, z, m] vertices.append(pt) return LineString(vertices, srid=4326) $$ LANGUAGE plpython3u; These are also sometimes called Mode-S codes.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMatthias Schäfer, Martin Strohmeier, Vincent Lenders, Ivan Martinovic, Matthias Wilhelm. \u0026ldquo;Bringing up OpenSky: A large-scale ADS-B sensor network for research\u0026rdquo;. In Proceedings of the 13th IEEE/ACM International Symposium on Information Processing in Sensor Networks (IPSN), pages 83-94, April 2014.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nICAO 24 numbers are often found in upper case online, but most OpenSky API endpoints accept them only in lower case.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSee this forum comment for confirmation that this is how OpenSky reports altitude and for a recommendation to use interpolation to smooth out the steps.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOn a system that uses systemd as a service manager, environment variables can be set in a configuration file added to /etc/systemd/system/postgresql.service.d.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOne disadvantage, however, is that the function is tied to this table.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTraffic Collision Avoidance System.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 July 2022","permalink":"/pages/ads-b/","section":"Pages","summary":"ADS-B data # Can standard geospatial tools be used with transmissions from Automatic Dependent Surveillance-Broadcast (ADS-B) equipment aboard aircraft? I wanted to find out because unlike most geospatial data, ADS-B has a third dimension and a fourth dimension.","title":"Multidimensional data in PostGIS"},{"content":"","date":"1 July 2022","permalink":"/tags/postgis/","section":"Tags","summary":"","title":"postgis"},{"content":"","date":"1 July 2022","permalink":"/tags/postgres/","section":"Tags","summary":"","title":"postgres"},{"content":" An Ottoman constructed language World-famous constructed languages range from Zamenhof\u0026rsquo;s Esperanto to Tolkien\u0026rsquo;s Quenya to hobbyist \u0026ldquo; conlangs\u0026rdquo;, but isn\u0026rsquo;t it surprising to learn that centuries before them, an Ottoman in Egypt created his own language and that a thorough grammar and lexicon survives to this day?\nConlanging before it became cool was the scholar and mystic Mehmed ibn Fethullah ibn Ebü Tâlib, born in Edirne in the mid-16th century and spending the majority of his life in Ottoman Cairo.\nI started writing an English-language overview of Bāla’y-balan\u0026rsquo;s grammar based on both the original text as preserved in Princeton University\u0026rsquo;s library and a modern Turkish translation by Mustafa Koç, Bâleybelen. Muhyî-i Gülşenî. İlk Yapma Dil.\nA page from Kitâb-ı Bâleybelen The \u0026ldquo;full\u0026rdquo; PDF is available for download, but here are a few short excerpts:\nWords in Bāla’y-balan are not required to have vowel harmony, a distinguishing feature of the Turkish language. Words such as qaydak kapı \u0026lsquo;door, gate\u0026rsquo;, which has both a back q and a front k, would not be possible in a pure Turkish word. This point has further significance when we consider Bāla’y-balan’s suffixes, which will not harmonise with the vowels in the root to which they are attached.\nThe Bāla’y-balan plural is created by the addition of the suffix -ā: نو niv \u0026lsquo;flower\u0026rsquo; and نوا nivā \u0026lsquo;flowers\u0026rsquo;. When the base noun already ends with a -ā, then -y- is added as a buffer between the two vowels. When the base noun ends in the vowel ه [a], then the long ā is added, and the ه is vocalised with its consonontal value [h]: ظفه ẓafa \u0026lsquo;book\u0026rsquo;, ظفها ẓafahā.\nA noun may be placed in accusative case by the addition of the suffix -rā. This may be added to both singular and plural nouns: شَمْسَا نِوَارَا Şamsā nivārā \u0026lsquo;They smelled the flowers\u0026rsquo;.\nBāla’y-balan is available under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. Download ","date":"1 March 2018","permalink":"/pages/balaybalan/","section":"Pages","summary":"An Ottoman constructed language World-famous constructed languages range from Zamenhof\u0026rsquo;s Esperanto to Tolkien\u0026rsquo;s Quenya to hobbyist \u0026ldquo; conlangs\u0026rdquo;, but isn\u0026rsquo;t it surprising to learn that centuries before them, an Ottoman in Egypt created his own language and that a thorough grammar and lexicon survives to this day?","title":"Bāla’y-balan"},{"content":"","date":"1 March 2018","permalink":"/tags/language/","section":"Tags","summary":"","title":"language"},{"content":"","date":"1 August 2017","permalink":"/tags/postgresql/","section":"Tags","summary":"","title":"postgresql"},{"content":"I authored two Python modules that make it easier to use geospatial Python from within your PostgreSQL database.\nplpygis # plpygis is a Python conveter to and from the PostGIS geometry type, WKB, EWKB, GeoJSON and Shapely geometries and additionally supports __geo_interface__. plpygis is intended for use in PL/Python functions, making the entire Python geospatial ecosystem available in SQL queries.\nbosth/plpygis PL/Python for PostGIS Python 18 3 A simple Python function using plpygis would be:\nCREATE OR REPLACE FUNCTION swap(geom geometry) RETURNS geometry AS $$ # swaps the x and y coordinates of a point from plpygis import Geometry, Point old_point = Geometry(geom) new_point = Point([old_point.y, old_point.x]) return new_point $$ LANGUAGE plpython3u; The magic happens with Geometry(geom), which is automatically converts from PostGIS\u0026rsquo;s geometry type, and the return statement, which automatically converts back to a PostGIS geometry.\nThe function above can be called with a normal SQL statement:\nSELECT swap(geom) FROM city; I spoke about plpygis at FOSS4G 2017 in Boston. The slides are here and a video of the talk is also available.\nDocumentation geofdw # geofdw is a collection of PostGIS-related foreign data wrappers for PostgreSQL written in Python using the multicorn extension. By using a FDW, you can access spatial data through Postgres tables without having to import the data first, which can be useful for dynamic or non-tabular data available through web services.\nbosth/geofdw Various PostGIS-related FDWs Python 19 3 ","date":"1 August 2017","permalink":"/pages/python-postgis/","section":"Pages","summary":"I authored two Python modules that make it easier to use geospatial Python from within your PostgreSQL database.\nplpygis # plpygis is a Python conveter to and from the PostGIS geometry type, WKB, EWKB, GeoJSON and Shapely geometries and additionally supports __geo_interface__.","title":"Python for PostGIS"},{"content":" An Ottoman Turkish tautology Wikipedia has an article on a place called Pendle Hill, noteworthy, perhaps, mainly for being a triple tautology:\nThe name \u0026ldquo;Pendle Hill\u0026rdquo; combines the words for hill from three different languages \u0026hellip; In the 13th century it was called Pennul or Penhul, apparently from the Cumbric pen and Old English hyll, both meaning \u0026ldquo;hill\u0026rdquo;. The modern English \u0026ldquo;hill\u0026rdquo; was appended later, after the original meaning of Pendle had become opaque.\nThis reminded me of a similar triple tautology I came across as a graduate student reading copies of a monthly journal from the early twentieth century.\nMürşid-i Âsûriyûn, May 1912 Reading right-to-left, you can see it right there at the start of the second line: ܔܒܠܛܘܪ ܛܐܓ݂ . That\u0026rsquo;s cebel (Arabic for \u0026ldquo;mountain\u0026rdquo;), tûr (Syriac for \u0026ldquo;mountain\u0026rdquo;) and dağ (Turkish for, you guessed it, \u0026ldquo;mountain\u0026rdquo;).1\nThe text above was written in Ottoman Turkish, and for consistency, I am using standard Turkish transliteration for all the foreign language words. It\u0026rsquo;s worth pointing out that cebel is pronounced \u0026ldquo;jebel\u0026rdquo;. The \u0026ldquo;mountain\u0026rdquo; in question here was actually the Tur Abdin region in modern Turkey, ironically a region that has no mountains and can be described as hilly at best.\nAs a small aside, the journal Mürşid-i Âsûriyûn that this place name came from is interesting a in a few ways:\nIf the image above looks handwritten, that\u0026rsquo;s because it was. The publisher, Âşûr Yûsuf, printed copies using a technique called mimeography. The journal existed between 1909 and 1914 in the ancient city of Harpût, then a provincial capital and was mailed to subscribers across the Ottoman Empire and as far away as the United States. This preserved copy comes from a subscriber in Massachusetts. Ottoman Turkish was usually written using the Arabic alphabet, but Âşûr Yûsuf used the Syriac alphabet in Mürşid-i Âsûriyûn. This was the first journal to be printed in Ottoman Turkish with Syriac letters, but it was followed by several more. You could still find them being published in Lebanon and the United States into the 1930s. Syriac Arabic Latin ܔܒܠ جبل cebel ܛܘܪ طور tûr ܛܐܓ݂ طاغ dağ Âşûr Yûsuf was a native speaker of Armenian and he did not know the Syriac language, despite identifying as a Syriac (Süryânî) and an Assyrian (Âsûrî). Like any other speaker of Ottoman Turkish, he would have been well-acquainted with the common word cebel despite not speaking Arabic himself.\nIt\u0026rsquo;s interesting to compare his usage to some other notable topological features in the Ottoman Empire:\nMount Sinai is جبل الطور (Cebel et-Tûr) in Arabic and was جبل طور (Cebel‑i Tûr) in Ottoman Turkish.2 The Mount of Olives near Jerusalem was also Cebel‑i Tûr (although it is simply الطور in Arabic). Mount Gerizim near Nablus is another Cebel et-Tûr. In the Arabic and the Ottoman cases where we find both cebel and tûr, speakers would have understood these names to mean something like \u0026ldquo;Tûr Mountain\u0026rdquo;.\nWhen I originally read the passage above, I also transliterated the place name as Cebel‑i Tûr Dağı, but looking at the text again, I can see that the author intended it to be read Cebeltûr Dağı. My original reading would have required a space between the first two words, so ܔܒܠ ܛܘܪ ܛܐܓ݂ , but that space is quite clearly not there: ܔܒܠܛܘܪ ܛܐܓ݂ .\nAnd that, I suppose, is the difference. Cebel-i Tûr (with a space) was \u0026ldquo;Mount Tûr\u0026rdquo; and no Dağ was necessary or even possible. But Cebeltûr (no space) had become a set phrase much like Penhul. And it was acceptable for a Turkish-speaker to call this place Cebeltûr Dağı: \u0026ldquo;Mount Cebeltûr\u0026rdquo;.\nObservant readers will note that it is actually ܔܒܠܛܘܪ ܛܐܓ݂ܢܢ in the original text but the final two characters are the Turkish grammatical suffix -ının which we can ignore.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIn Turkish today, Tûr Dağı has replaced the Persian grammatical construct which you see in Cebel-i Tûr. And both now and then, Mount Sinai had many different names, including Cebel-i Sînâ.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 January 2016","permalink":"/pages/mt-mountain-mountain/","section":"Pages","summary":"An Ottoman Turkish tautology Wikipedia has an article on a place called Pendle Hill, noteworthy, perhaps, mainly for being a triple tautology:\nThe name \u0026ldquo;Pendle Hill\u0026rdquo; combines the words for hill from three different languages \u0026hellip; In the 13th century it was called Pennul or Penhul, apparently from the Cumbric pen and Old English hyll, both meaning \u0026ldquo;hill\u0026rdquo;.","title":"Mount Mountain Mountain"},{"content":"","date":"1 January 2016","permalink":"/tags/syriac/","section":"Tags","summary":"","title":"syriac"},{"content":" Primary sources on Syriacs of Ottoman Adıyaman The linked monograph is a transcription Ottoman Turkish into the Latin alphabet of texts relating to the Syriac (Süryânî) community in Adıyaman and its environs. The document is composed of two parts, first being Adıyaman Tarihi, a manuscript written in Syria in the mid-twentieth century. The second part is a collection of articles collected from early-twentieth century Syriac newspapers in both the Ottoman Empire and the United States. All of the above were written in Syro-Ottoman (Ottoman Turkish using the Syriac alphabet) and the transcription reflects the original language. Notably, Adıyaman Tarihi exhibits many non-standard grammatical and orthographic practices, and these have been faithfully preserved here. The document also contains a glossary of Ottoman and Adıyaman dialectal terms so that the texts can be read by modern-day Turkish speakers.\nAdıyaman Tarihi # Adıyaman Tarihi is one of the most remarkable works I have had the pleasure of working on: a first-hand account of the lives of the Syriac population in the Ottoman town of Adıyaman (also known as Hısn-ı Mansûr) during the late Ottoman Empire. The author escapes the local massacres with his life, but in light of ongoing post-war persecution, he eventually flees to mandate Syria, where he would spend the rest of his life.\nPage from Adıyaman Tarihi I gave a talk on the text during SAYFO 1915: An International Conference on the Genocide of Assyrians/Arameans during the First World War held at Freie Universität Berlin in 2015.\nInternational Conference: Seyfo 1915\nA map from the text was also featured on the lovely The Afternoon Map blog devoted to Ottoman and Ottoman-adjacent cartography.1\nAdıyamanlı Süryânîler is available under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. Download Another map I submitted is available as a post entitle The New Assyria.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 January 2015","permalink":"/pages/adiyaman/","section":"Pages","summary":"Primary sources on Syriacs of Ottoman Adıyaman The linked monograph is a transcription Ottoman Turkish into the Latin alphabet of texts relating to the Syriac (Süryânî) community in Adıyaman and its environs.","title":"Adıyamanlı Süryânîler"},{"content":"I did my graduate studies at Boğaziçi Üniversitesi in Istanbul under the direction of the Vangelis Kechriotis. My research topic was the Ottoman Süryânî (Syriac) community during the Second Constitutional Period.\nPublications # The Ottoman Süryânî from 1908 to 1914 # This is the first academic work to rely on primary sources written in the Syro-Ottoman language and attempts to apply Ottomanist historiography to Syriac history. It was first published by Gorgias Press in 2009 and received its second printing in 2019.\nFrom the publisher\u0026rsquo;s website:\nThis work explores the misconceptions about the Ottoman Süryânî community of the pre-World War I era, using a critique of the present day historiography as the context for the discussion. The works of three early twentieth century journalists, provide the material for the study. The author contends that this group cannot be considered as Assyrian nationalists, the traditional argument, that they saw the future of the Süryânî people as best secured by the continuation of the Ottoman Empire, in which they sought a greater presence for their community.\nOther # \u0026ldquo; A Bibliography of Süryânî Periodicals in Ottoman Turkish\u0026rdquo; in Hugoye: Journal of Syriac Studies. 12, no. 1: 287-300.\n\u0026ldquo;A Description of Syro-Ottoman\u0026rdquo; in Between religion and language: Turkish-speaking Christians, Jews and Greek-speaking Muslims and Catholics in the Ottoman Empire. İstanbul: Eren, 2012.\nAdıyaman Tarihi. Unpublished.\n","date":"1 January 2013","permalink":"/pages/ottomansuryani/","section":"Pages","summary":"I did my graduate studies at Boğaziçi Üniversitesi in Istanbul under the direction of the Vangelis Kechriotis. My research topic was the Ottoman Süryânî (Syriac) community during the Second Constitutional Period.","title":"The Ottoman Süryânî"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]